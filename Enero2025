#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Fri Jan 10 08:40:54 2025

@author: diego
"""

# main.py
import os
import numpy as np
import pandas as pd
import csv # PARA ENCONTRAR EL TIPO DE DELIMITADOR DEL ARCHIVO .CSV
import re # PARA LA EXPRECION REGULAR DE LOS SUFIJOS
import time
import matplotlib
import matplotlib.pyplot as plt
import matplotlib.colors as mcolors
import sys  # Para usar sys.exit()
from sklearn.preprocessing import StandardScaler # PARA LA NORMALIZACION POR LA MEDIA 
from sklearn.decomposition import PCA
from scipy.signal import savgol_filter # Para suavizado de Savitzky Golay
from scipy.ndimage import gaussian_filter # PARA EL FILTRO GAUSSIANO
from sklearn.cluster import AgglomerativeClustering
from scipy.cluster.hierarchy import linkage, cut_tree, dendrogram


pila = []

def archivo_existe(ruta_archivo):
    # print("Buscando archivo.")
    # time.sleep(3)
    # print("Buscando archivo..")
    # time.sleep(2)
    print("Buscando archivo...")
    time.sleep(1)
    return os.path.isfile(ruta_archivo)

nombre = input("Por favor, ingresa tu nombre: ")
print(f"Hola, {nombre}!")

existe = False
archivo_nombre = input("Ingrese el nombre del archivo: ")

 

# Función para detectar el delimitador automáticamente por que los archivos pueden estar ceparados por , o ; etc
def identificar_delimitador(archivo):
    with open(archivo, 'r') as file:
        muestra_csv = file.read(4096)  # Lee una muestra de 4096 bytes
        #print("LA MUESTRA DEL CSV ES:")
        #print(muestra_csv)
        caracter = csv.Sniffer()
        delimitador = caracter.sniff(muestra_csv).delimiter
    return delimitador




def detectar_labels(df): #Detecta si los labels están en la fila o en la columna para ver si hacemos la transpuesta  o no

    # Verificar la primera fila (si contiene strings)
    if df.iloc[0].apply(lambda x: isinstance(x, str)).all():
        return "fila" #si los labels están en la primera fila
    
    # Verificar la primera columna (si contiene strings)
    elif df.iloc[:, 0].apply(lambda x: isinstance(x, str)).all():
        return "columna" #si los labels están en la primera columna
    
    # Si no hay etiquetas detectadas
    return "ninguno" #si no se detectan labels.



while existe == False:   
    if archivo_existe(archivo_nombre):  
        # print("Encontrado!.")
        # print("Analizando archivo.")
        # time.sleep(3)
        # print("Analizando archivo..")
        # time.sleep(2)
        # print("Analizando archivo...")
        time.sleep(1)
        bd_name = archivo_nombre #Este archivo contiene los datos espectroscópicos que serán leídos
        delimitador = identificar_delimitador(bd_name)
        print("EL DELIMITADOR ES: ", delimitador)
        df = pd.read_csv(bd_name, delimiter = delimitador , header=None)
        pila.append(df.copy())
        existe = True
        if detectar_labels(df) == "columna" :
            print("SE HIZO LA TRASPUESTA")
            df = df.T
        else:
            print("NO SE HIZO LA TRANSPUESTA")
    else:
        print("El archivo no existe.")
        archivo_nombre = input("Ingrese el nombre del archivo: ")

# print("DF ANTES DEL CORTE")
# print(df)
# print(df.shape)

# print("LOGRO LEER EL ARCHIVO")


def columna_con_menor_filas(df):
    
    # Calcular el número de valores no nulos en cada columna
    valores_no_nulos = df.notna().sum()
    
    # Encontrar la columna con la menor cantidad de valores no nulos
    columna_menor = valores_no_nulos.idxmin()
    cantidad_menor = valores_no_nulos.min()
    
    return columna_menor, cantidad_menor


col,fil = columna_con_menor_filas(df)
if len(df) == fil:
    print("EL DATASET TIENE LA MISMA CANTIDAD DE FILAS EN CADA COLUMNA")
else:
    print("LA COLUMNA CON MENOR CANTIDAD DE DATOS ES:")
    print("TIPO: ",df.iloc[0,col+1])
    print("FILA: ",fil)
    print("COLUMNA: ",col+1)   
    print("DIMENSION DEL DATAFRAME", df.shape)
    opcion = 0
    while opcion != 6:
        print("COMO DESEAS ARREGLAR EL DATAFRAME")
        print("1- ELIMINAR TODAS LAS FILAS HASTA IGUALAR A LA MENOR")
        print("2- ELIMINAR LA COLUMNA CON MENOR NUMERO DE FILAS")
        print("3- VER DATAFRAME ACTUAL")
        print("4- VOLVER ATRAS")
        print("5- GENERAR .CSV")
        print("6- SALIR")
        opcion= int(input("OPCION: "))
        
        if opcion == 1:
            
            menor_cant_filas = df.dropna().shape[0] # Buscamos la columna con menor cantidad de intensidades
            # print("menor cantidad de filas:", menor_cant_filas)
    
            df_truncado = df.iloc[:menor_cant_filas] # Hacemos los cortes para igualar las columnas
    
            df = df_truncado
            
            pila.append(df.copy())
            # print(df.shape)
        elif opcion == 2:
            # print(df.shape)
            df.drop(columns=[col], inplace=True)
            # print(df.shape)
            pila.append(df.copy())
        elif opcion == 3:
            print(df)
        elif opcion == 4:
             if pila:
                 # Recuperar el último estado del DataFrame
                 df = pila.pop()
                 print("Se ha revertido al estado anterior.")
             else:
                 print("No hay acciones para deshacer.")
    
        elif opcion == 5:
            df.to_csv('output.csv', index=False, header=0)
        else:
            print("Saliendo")
        



# renombramos la celda [0,0]

# print("Cambiar a cero: ",df.iloc[0,0])

df.iloc[0,0] = float(0)

# print("Cambiar a cero: ",df.iloc[0,0])

#print(df)



# HACEMOS LA ELIMINACION DE LOS SUFIJOS EN CASO DE TENER


for col in df.columns:
    valor = re.sub(r'[_\.]\d+$', '', str(df.at[0, col]).strip())  # Eliminar sufijos con _ o .
    try:
        df.at[0, col] = float(valor)  # Convertir de nuevo a float si es posible
    except ValueError:
        df.at[0, col] = valor  # Mantener como string si no es convertible


# print("Luego de eliminar los sufijos")
print(df)



##### PENSAR EN COMO HACER LA OPCION DE IR HACIA ATRAS Y DE GENERAR .CSV PARA DESCARGAR

def mostrar_menu():
     print("\n--- Menú Principal ---")
     print("1. MOSTRAR ESPECTROS")
     print("2. NORMALIZAR POR MEDIA")
     print("3. NORMALIZAR POR AREA")
     print("4. SUAVIZADO POR SAVIZTKY-GOLAY")
     print("5. SUAVIZADO POR FILTRO GAUSIANO")
     print("6. SUAVIZADO POR MEDIA MOVIL")
     print("7. PRIMERA DERIVADA")
     print("8. SEGUNDA DERIVADA")
     print("9. CORRECCION BASE LINEAL")
     print("10. CORRECION SHIRLEY")
     print("11. PCA")
     print("12. GRAFICO DE LOADINGS")
     print("13. ESPECTRO ACOTADO")
     print("14. GRAFICO HCA")
     print("15. Salir")
      
def sub_menu():
    print("Como deseas ver el espectro")
    print("1- Grafico completo") #ok
    print("2- Grafico acotado") #ok
    print("3- Grafico por tipo") #ok
    print("4- Grafico acotado por tipo") #ok
    print("5- Descargar .csv ") #ok
    print("6- Descargar .csv acotado") #ok
    print("7- Descargar .csv por tipo") #ok
    print("8- Descargar .csv acotado por tipo")
    print("9- Volver") #ok
      
raman_shift = df.iloc[1:, 0].reset_index(drop=True)  # EXTRAEMOS TODA LA PRIMERA COLUMNA, reset_index(drop=True) SIRVE PARA QUE EL INDICE COMIENCE EN 0 Y NO EN 1
print(raman_shift)

tipos = df.iloc[0, 1:] # EXTRAEMOS LA PRIMERA FILA MENOS DE LA PRIMERA COLUMNA
#print(tipos)
cant_tipos = tipos.nunique() # PARA EL EJEMPLO DE LIMPIO.CSV CANT_TIPOS TENDRA VALOR 4 YA QUE HAY 4 TIPOS (collagen,lipids,glycogen,DNA)
#print(cant_tipos)
tipos_nombres = df.iloc[0, 1:].unique() # OBTENEMOS LOS NOMBRES DE LOS TIPOS
#print(tipos_nombres)

# Seleccionar un colormap distintivo
cmap = plt.cm.Spectral  # Puedes probar con "hsv", "Set3", "Spectral", etc.

#cmap = plt.colormaps['hsv']  # Usamos solo el nombre del colormap, Obtenemos el colormap sin especificar el número de colores

# Nos aseguramos de que `colores` es una lista
colores = [cmap(i) for i in np.linspace(0, 1, len(tipos_nombres))]  # Genera una lista de colores

# Crear el diccionario de asignación de colores
asignacion_colores = {tipo: mcolors.to_hex(colores[i]) for i, tipo in enumerate(tipos_nombres)}
#print(asignacion_colores)

diccionario=pd.DataFrame(asignacion_colores.items())
 #print(diccionario)



# MOSTRAMOS LA LEYENDA PARA CADA TIPO
plt.figure(figsize=(2,2))    
for index, row in diccionario.iterrows():
    #print('entro 15')
    tipo = row[0]   # Nombre del tipo (por ejemplo, 'collagen')
    color = row[1]  # Color asociado (por ejemplo, '#ff0000')
    plt.plot([], [], color=color, label=tipo) 
# Mostrar la leyenda y el gráfico
#print('entro 20')
plt.legend(loc='center')
plt.grid(False)
plt.title(f'Cantidad de tipos encontrados {cant_tipos}')
plt.axis('off')
plt.show()




def datos_sin_normalizar():
        
    df2 = df.copy()
    df2.columns = df2.iloc[0]
    #print(df2)
    df2 = df2.drop(0).reset_index(drop=True) #eliminamos la primera fila
    df2 = df2.drop(df2.columns[0], axis=1) #eliminamos la primera columna el del rama_shift
    #print(df2) # aca ya tenemos la tabla de la manera que necesitamos, fila cero es la cabecera con los nombres de los tipos anteriormente eran indice numericos consecutivos
    df2 = df2.apply(pd.to_numeric, errors='coerce') #CONVERTIMOS A NUMERICO
    #print("EL DATAFRAME DEL ESPECTRO SIN NORMALIZAR ES")
    #print(df2) #ESTA VARIABLE SE USA PARA EL PCA TAMBIEN
    #print(df2.shape)
    # print("DF22222")
    # print(df2)
    return df2


"""
VARIABLES DE NORMALIZAR POR LA MEDIA    tratar de hacer por la forma del ejemplo y no por z-core para ver si se soluciona lo de la raya
"""
def normalizado_media():
        
    intensity = df.iloc[1:, 1:] # EXTRAEMOS TODAS DEMAS COLUMNAS EXCEPTO LA PRIMERA FILA Y PRIMERA COLUMNA
    #print(intensity)     
    cabecera = df.iloc[[0]].copy() # EXTRAEMOS LA PRIMERA FILA 
    #print(cabecera)
    #print(cabecera.shape)
    scaler = StandardScaler() 
    cal_nor = scaler.fit_transform(intensity) #calcula la media y desviación estándar
    #print(cal_nor)
    dato_normalizado = pd.DataFrame(cal_nor, columns=intensity.columns) # lo convertimos de vuelta en un DataFrame
    #print(dato_normalizado)
    df_concatenado = pd.concat([cabecera,dato_normalizado], axis=0, ignore_index=True)
    #print(df_concatenado)
    #  Convertimos la primera fila en cabecera
    df_concatenado.columns = df_concatenado.iloc[0]  # Asigna la primera fila como nombres de columna
    # Eliminamos la primera fila (ahora es la cabecera) y reseteamos el índice
    df_concatenado_cabecera_nueva = df_concatenado[1:].reset_index(drop=True)
    #print(df_concatenado_cabecera_nueva.head(50))
    df_media_pca= pd.DataFrame(df_concatenado_cabecera_nueva.iloc[:,1:])
    #print("EL ESPECTRO NORMALIZADO POR LA MEDIA ES")
    #print(df_media_pca) #ESTA VARIABLE SE USA PARA EL PCA TAMBIEN
    #print('normalizacion media')
    #df_media_pca.to_csv("nor_media_df.csv", index=False)
    return  df_media_pca


"""
VARIABLES DE NORMALIZAR POR AREA    tratar de hacer otro sin np.trap para ver si se soluciona lo de la raya
"""
def normalizado_area():
    
    intensity = df.iloc[1:, 1:] # EXTRAEMOS TODAS DEMAS COLUMNAS EXCEPTO LA PRIMERA FILA Y PRIMERA COLUMNA
    #print(intensity)  
    
    cabecera = df.iloc[[0]].copy() # EXTRAEMOS LA PRIMERA FILA 
    #print(cabecera)
    
    df3 = pd.DataFrame(intensity)
    #print("DataFrame de Intensidades:")
    #print(df3)
    df3 = df3.apply(pd.to_numeric, errors='coerce')  # Convierte a numérico, colocando NaN donde haya problemas
    #print(df3)
    np_array = raman_shift.astype(float).to_numpy() #CONVERTIMOS INTENSITY AL TIPO NUMPY POR QUE POR QUE NP.TRAPZ UTILIZA ESE TIPO DE DATOS
    #print("valor de np_array: ")
    #print(np_array)
    
    df3_normalizado = df3.copy()
    #print("EL VALOR DE DF3 ES :")
    #print(df3)
    # Cálculamos el área bajo la curva para cada columna
    #print("\nÁreas bajo la curva para cada columna:")
    for col in df3.columns:
        #print(df3[col])
        #print(df3_normalizado[col])
        
        # np.trapz para hallar el area bajo la curva por el metodo del trapecio
        area = (np.trapz(df3[col], np_array)) *-1  #MULTIPLIQUE POR -1 PARA QUE EL GRAFICO SALGA TODO HACIA ARRIBA ESTO SE DEBE A QUE EL RAMAN_SHIFT ESTA EN FORMA DECRECIENTE
        if area != 0:
            df3_normalizado[col] = df3[col] / area
        else:
            print(f"Advertencia: El área de la columna {col} es cero y no se puede normalizar.") #seguro contra errores de división por cero 
    #print(df3_normalizado)
    df_concatenado_area = pd.concat([cabecera,df3_normalizado], axis=0, ignore_index=True)
    #print(df_concatenado_area)
    # Paso 1: Convertir la primera fila en cabecera
    df_concatenado_area.columns = df_concatenado_area.iloc[0]  # Asigna la primera fila como nombres de columna
    # Paso 2: Eliminar la primera fila (ahora es la cabecera) y resetear el índice
    df_concatenado_cabecera_nueva_area = df_concatenado_area[1:].reset_index(drop=True)
    # AHORA ELIMINAMOS LA COLUMNA CON VALORES NAN
    df_concatenado_cabecera_nueva_area = df_concatenado_cabecera_nueva_area.dropna(axis=1, how='all')
    #print("ESPECTRO NORMALIZADO POR EL AREA")
    #print(df_concatenado_cabecera_nueva_area) #ESTA VARIABLE SE USA PARA EL PCA TAMBIEN
    #print('entro 10')
    #df_concatenado_cabecera_nueva_area.to_csv("nor_area_df.csv", index=False)
    return df_concatenado_cabecera_nueva_area



'''
    PREPARAMOS EL SIGUIENTE MENU
'''


def main():
    while True:
        mostrar_menu()
        opcion = input("Selecciona una opción: ")
        print("volvio a salir")
        if opcion == '1':
            
            metodo = 1
            sub_menu()
            metodo_grafico = int(input("Opcion: "))
            if metodo_grafico == 1:
                print("Procesando los datos")
                print("Por favor espere un momento...")
                mostrar_espectros(datos_sin_normalizar(),raman_shift,metodo,0,0,0)
            elif metodo_grafico == 2:
                espectro_acotado(datos_sin_normalizar(), 0,1,0,0)
            elif metodo_grafico == 3:
                grafico_tipo(datos_sin_normalizar(),raman_shift,0,metodo,0,0)
            elif metodo_grafico == 4:
                grafico_acotado_tipo(datos_sin_normalizar(),raman_shift,metodo,0,0,0)
            elif metodo_grafico == 5: 
                descargar_csv(1,datos_sin_normalizar()) # 1 PARA SABER QUE VIENE SIN NORMALIZAR  
            elif metodo_grafico == 6:
                descargar_csv_acotado(datos_sin_normalizar(),1) # 1 PARA SABER QUE VIENE DE ACA Y PODER ELEGIR EL NOMBRE DE LA CARPETA DE SALIDA
            elif metodo_grafico == 7:
                descargar_csv_tipo(datos_sin_normalizar(),1) # 1 PARA SABER QUE VIENE SIN NORMALIZAR  
            elif metodo_grafico == 8:
                descargar_csv_acotado_tipo(datos_sin_normalizar(),1) # 1 PARA SABER QUE VIENE SIN NORMALIZAR  
            elif metodo_grafico == 9:
                main()
                
                
        elif opcion == '2':
            
            metodo = 2
            sub_menu()
            metodo_grafico = int(input("Opcion: "))
            if metodo_grafico == 1:
                print("Procesando los datos")
                print("Por favor espere un momento...")
                mostrar_espectros(normalizado_media(),raman_shift,metodo,0,0,0)
            elif metodo_grafico == 2:
                espectro_acotado(normalizado_media(), 0,2,0,0)
            elif metodo_grafico == 3:
                grafico_tipo(normalizado_media(),raman_shift,0,metodo,0,0)
            elif metodo_grafico == 4:
                grafico_acotado_tipo(normalizado_media(),raman_shift,metodo,0,0,0)
            elif metodo_grafico == 5:
                descargar_csv(2,normalizado_media()) # 2 PARA SABER QUE VIENE DE LA MEDIA  
            elif metodo_grafico == 6:
                descargar_csv_acotado(normalizado_media(),2) # 2 PARA SABER QUE VIENE DE ACA Y PODER ELEGIR EL NOMBRE DE LA CARPETA DE SALIDA
            elif metodo_grafico == 7:
                descargar_csv_tipo(normalizado_media(),2) # 2 PARA SABER QUE VIENE  NORMALIZAR MEDIA
            elif metodo_grafico == 8:
                descargar_csv_acotado_tipo(normalizado_media(),2) # 2 PARA SABER QUE VIENE SIN NORMALIZAR 
            elif metodo_grafico == 9:
                main()
                
                
        elif opcion == '3': 
            
             metodo = 3
             sub_menu()
             metodo_grafico = int(input("Opcion: "))
                 
             if metodo_grafico == 1:
                 print("Procesando los datos")
                 print("Por favor espere un momento...")
                 mostrar_espectros(normalizado_area(),raman_shift,metodo,0,0,0)
             elif metodo_grafico == 2:
                 espectro_acotado(normalizado_area(), 0,3,0,0)
             elif metodo_grafico == 3:
                 grafico_tipo(normalizado_area(),raman_shift,0,metodo,0,0)
             elif metodo_grafico == 4:
                 grafico_acotado_tipo(normalizado_area(),raman_shift,metodo,0,0,0)
             elif metodo_grafico == 5:
                 descargar_csv(3,normalizado_area()) # 3 PARA SABER QUE VIENE DEL AREA   
             elif metodo_grafico == 6:
                descargar_csv_acotado(normalizado_area(),3) # 3 PARA SABER QUE VIENE DE ACA Y PODER ELEGIR EL NOMBRE DE LA CARPETA DE SALIDA
             elif metodo_grafico == 7:
                 descargar_csv_tipo(normalizado_area(),3) # 3 PARA SABER QUE VIENE  NORMALIZAR AREA
             elif metodo_grafico == 8:
                 descargar_csv_acotado_tipo(normalizado_area(),3) # 3 PARA SABER QUE VIENE SIN NORMALIZAR 
             elif metodo_grafico == 9:
                 main()
         
        elif opcion == '4':  
            print("sigue dentro")
            while True:  # Bucle para mantener al usuario en el submenú
              metodo = 4
              
              sub_menu()
              metodo_grafico = int(input("Opcion: "))               
              if metodo_grafico == 1:
                  dato,nor_op = suavizado_menu()
                  if dato is None:  # Manejar la opción "Volver"
                      continue # EVITA QUE CONTINUE LA EJECUCION DE LAS LINEAS RESTANTES Y SALTA AL SIGUIENTE CICLO
                  dato_suavizado = suavizado_saviztky_golay(dato)
                  mostrar_espectros(dato_suavizado,raman_shift,metodo,nor_op,0,0)
              elif metodo_grafico == 2:
                  dato,nor_op = suavizado_menu()
                  if dato is None:  # Manejar la opción "Volver"
                      continue 
                  dato_suavizado = suavizado_saviztky_golay(dato)
                  if nor_op == 1:
                      metodo = 4
                  elif nor_op == 2:
                      metodo = 5
                  elif nor_op == 3:
                      metodo = 6
                  espectro_acotado(dato_suavizado,0,metodo,0,0)
              elif metodo_grafico == 3:
                  dato,nor_op = suavizado_menu()
                  if dato is None:  # Manejar la opción "Volver"
                      continue 
                  dato_suavizado = suavizado_saviztky_golay(dato)
                  grafico_tipo(dato_suavizado,raman_shift,nor_op,metodo,0)
              elif metodo_grafico == 4:
                  dato,nor_op = suavizado_menu()
                  if dato is None:  # Manejar la opción "Volver"
                      continue 
                  dato_suavizado = suavizado_saviztky_golay(dato)
                  grafico_acotado_tipo(dato_suavizado,raman_shift,metodo,nor_op,0,0)
              elif metodo_grafico == 5:
                  dato,nor_op = suavizado_menu()
                  if dato is None:  # Manejar la opción "Volver"
                      continue 
                  dato_suavizado = suavizado_saviztky_golay(dato)
                  descargar_csv(4, dato_suavizado) # 4 PARA SABER QUE VIENE DEL SUAVIZADO POR suavizado_saviztky_golay
              elif metodo_grafico == 6:
                  dato,nor_op = suavizado_menu()
                  if dato is None:  # Manejar la opción "Volver"
                      continue 
                  dato_suavizado = suavizado_saviztky_golay(dato)
                  descargar_csv_acotado(dato_suavizado,4) # 4 PARA SABER QUE VIENE DE ACA Y PODER ELEGIR EL NOMBRE DE LA CARPETA DE SALIDA
              elif metodo_grafico == 7:
                  dato,nor_op = suavizado_menu()
                  if dato is None:  # Manejar la opción "Volver"
                      continue 
                  dato_suavizado = suavizado_saviztky_golay(dato)
                  descargar_csv_tipo(dato_suavizado,4) # 4 PARA SABER QUE VIENE DE ACA Y PODER ELEGIR EL NOMBRE DE LA CARPETA DE SALIDA
              elif metodo_grafico == 8:
                  dato,nor_op = suavizado_menu()
                  if dato is None:  # Manejar la opción "Volver"
                      continue 
                  dato_suavizado = suavizado_saviztky_golay(dato)
                  descargar_csv_acotado_tipo(dato_suavizado,4) # 4 PARA SABER QUE VIENE DE ACA Y PODER ELEGIR EL NOMBRE DE LA CARPETA DE SALIDA
              elif metodo_grafico == 9:
                  main()
        elif opcion == '5':  
              print("sigue dentro")
              while True:  # Bucle para mantener al usuario en el submenú
                metodo = 5           
                sub_menu()
                metodo_grafico = int(input("Opcion: "))               
                if metodo_grafico == 1:
                    dato,nor_op = suavizado_menu()
                    if dato is None:  # Manejar la opción "Volver"
                        continue # EVITA QUE CONTINUE LA EJECUCION DE LAS LINEAS RESTANTES Y SALTA AL SIGUIENTE CICLO
                    dato_suavizado = suavizado_filtroGausiano(dato)
                    mostrar_espectros(dato_suavizado,raman_shift,metodo,nor_op,0,0)
                elif metodo_grafico == 2:
                    dato,nor_op = suavizado_menu()
                    if dato is None:  # Manejar la opción "Volver"
                        continue 
                    dato_suavizado = suavizado_filtroGausiano(dato)
                    if nor_op == 1:
                        metodo = 7
                    elif nor_op == 2:
                        metodo = 8
                    elif nor_op == 3:
                        metodo = 9
                    espectro_acotado(dato_suavizado,0,metodo,0,0)
                elif metodo_grafico == 3:
                    dato,nor_op = suavizado_menu()
                    if dato is None:  # Manejar la opción "Volver"
                        continue 
                    dato_suavizado = suavizado_filtroGausiano(dato)
                    grafico_tipo(dato_suavizado,raman_shift,nor_op,metodo,0,0)
                elif metodo_grafico == 4:
                    dato,nor_op = suavizado_menu()
                    if dato is None:  # Manejar la opción "Volver"
                        continue 
                    dato_suavizado = suavizado_filtroGausiano(dato)
                    grafico_acotado_tipo(dato_suavizado,raman_shift,metodo,nor_op,0,0)
                elif metodo_grafico == 5:
                    dato,nor_op = suavizado_menu()
                    if dato is None:  # Manejar la opción "Volver"
                        continue 
                    dato_suavizado = suavizado_filtroGausiano(dato)
                    descargar_csv(5, dato_suavizado) # 5 PARA SABER QUE VIENE DEL SUAVIZADO POR Filtro Gaussiano
                elif metodo_grafico == 6:
                    dato,nor_op = suavizado_menu()
                    if dato is None:  # Manejar la opción "Volver"
                        continue 
                    dato_suavizado = suavizado_filtroGausiano(dato)
                    descargar_csv_acotado(dato_suavizado,5) # 5 PARA SABER QUE VIENE DE ACA Y PODER ELEGIR EL NOMBRE DE LA CARPETA DE SALIDA
                elif metodo_grafico == 7:
                    dato,nor_op = suavizado_menu()
                    if dato is None:  # Manejar la opción "Volver"
                        continue 
                    dato_suavizado = suavizado_filtroGausiano(dato)
                    descargar_csv_tipo(dato_suavizado,5) # 5 PARA SABER QUE VIENE DE ACA Y PODER ELEGIR EL NOMBRE DE LA CARPETA DE SALIDA
                elif metodo_grafico == 8:
                    dato,nor_op = suavizado_menu()
                    if dato is None:  # Manejar la opción "Volver"
                        continue 
                    dato_suavizado = suavizado_filtroGausiano(dato)
                    descargar_csv_acotado_tipo(dato_suavizado,5) # 5 PARA SABER QUE VIENE DE ACA Y PODER ELEGIR EL NOMBRE DE LA CARPETA DE SALIDA
                elif metodo_grafico == 9:
                    main()    
        elif opcion == '6':  
                print("sigue dentro")
                while True:  # Bucle para mantener al usuario en el submenú
                  metodo = 6          
                  sub_menu()
                  metodo_grafico = int(input("Opcion: "))               
                  if metodo_grafico == 1:
                      dato,nor_op = suavizado_menu()
                      if dato is None:  # Manejar la opción "Volver"
                          continue # EVITA QUE CONTINUE LA EJECUCION DE LAS LINEAS RESTANTES Y SALTA AL SIGUIENTE CICLO
                      dato_suavizado = suavizado_mediamovil(dato)
                      mostrar_espectros(dato_suavizado,raman_shift,metodo,nor_op,0,0)
                  elif metodo_grafico == 2:
                      dato,nor_op = suavizado_menu()
                      if dato is None:  # Manejar la opción "Volver"
                          continue 
                      dato_suavizado = suavizado_mediamovil(dato)
                      if nor_op == 1:
                          metodo = 10
                      elif nor_op == 2:
                          metodo = 11
                      elif nor_op == 3:
                          metodo = 12
                      espectro_acotado(dato_suavizado,0,metodo,0,0)
                  elif metodo_grafico == 3:
                      dato,nor_op = suavizado_menu()
                      if dato is None:  # Manejar la opción "Volver"
                          continue 
                      dato_suavizado = suavizado_mediamovil(dato)
                      grafico_tipo(dato_suavizado,raman_shift,nor_op,metodo,0,0)
                  elif metodo_grafico == 4:
                      dato,nor_op = suavizado_menu()
                      if dato is None:  # Manejar la opción "Volver"
                          continue 
                      dato_suavizado = suavizado_mediamovil(dato)
                      grafico_acotado_tipo(dato_suavizado,raman_shift,metodo,nor_op,0,0)
                  elif metodo_grafico == 5:
                      dato,nor_op = suavizado_menu()
                      if dato is None:  # Manejar la opción "Volver"
                          continue 
                      dato_suavizado = suavizado_mediamovil(dato)
                      descargar_csv(6, dato_suavizado) # 6 PARA SABER QUE VIENE DEL SUAVIZADO POR media movil
                  elif metodo_grafico == 6:
                      dato,nor_op = suavizado_menu()
                      if dato is None:  # Manejar la opción "Volver"
                          continue 
                      dato_suavizado = suavizado_mediamovil(dato)
                      descargar_csv_acotado(dato_suavizado,6) # 6 PARA SABER QUE VIENE DE ACA Y PODER ELEGIR EL NOMBRE DE LA CARPETA DE SALIDA
                  elif metodo_grafico == 7:
                      dato,nor_op = suavizado_menu()
                      if dato is None:  # Manejar la opción "Volver"
                          continue 
                      dato_suavizado = suavizado_mediamovil(dato)
                      descargar_csv_tipo(dato_suavizado,6) # 6 PARA SABER QUE VIENE DE ACA Y PODER ELEGIR EL NOMBRE DE LA CARPETA DE SALIDA
                  elif metodo_grafico == 8:
                      dato,nor_op = suavizado_menu()
                      if dato is None:  # Manejar la opción "Volver"
                          continue 
                      dato_suavizado = suavizado_mediamovil(dato)
                      descargar_csv_acotado_tipo(dato_suavizado,6) # 6 PARA SABER QUE VIENE DE ACA Y PODER ELEGIR EL NOMBRE DE LA CARPETA DE SALIDA
                  elif metodo_grafico == 9:
                      main()                   
        elif opcion == '7':           
                    print("sigue dentro")
                    while True:  # Bucle para mantener al usuario en el submenú
                      metodo = 7          
                      sub_menu()
                      metodo_grafico = int(input("Opcion: "))               
                      if metodo_grafico == 1:
                          dato,nor_op ,m_suavi = suavizado_menu_derivadas()
                          if dato is None:  # Manejar la opción "Volver"
                              continue # EVITA QUE CONTINUE LA EJECUCION DE LAS LINEAS RESTANTES Y SALTA AL SIGUIENTE CICLO
                          dato_suavizado = primera_derivada(dato)
                          mostrar_espectros(dato_suavizado,raman_shift,metodo,nor_op,m_suavi,1)
                      elif metodo_grafico == 2:
                          dato,nor_op,m_suavi= suavizado_menu_derivadas()
                          if dato is None:  # Manejar la opción "Volver"
                              continue 
                          dato_suavizado = primera_derivada(dato)
                          espectro_acotado(dato_suavizado,0,nor_op,m_suavi,1)
                      elif metodo_grafico == 3:
                          dato,nor_op,m_suavi = suavizado_menu_derivadas()
                          if dato is None:  # Manejar la opción "Volver"
                              continue 
                          dato_suavizado = primera_derivada(dato)
                          grafico_tipo(dato_suavizado,raman_shift,nor_op,metodo,m_suavi,1)
                      elif metodo_grafico == 4:
                          dato,nor_op,m_suavi = suavizado_menu_derivadas()
                          if dato is None:  # Manejar la opción "Volver"
                              continue 
                          dato_suavizado = primera_derivada(dato)
                          grafico_acotado_tipo(dato_suavizado,raman_shift,metodo,nor_op,m_suavi,1)
                      elif metodo_grafico == 5:
                          dato,nor_op,m_suavi = suavizado_menu_derivadas()
                          if dato is None:  # Manejar la opción "Volver"
                              continue 
                          dato_suavizado = primera_derivada(dato)
                          descargar_csv(7, dato_suavizado) # 7 PARA SABER QUE VIENE DE LA PRIMERA DERIVADA
                      elif metodo_grafico == 6:
                          dato,nor_op,m_suavi = suavizado_menu_derivadas()
                          if dato is None:  # Manejar la opción "Volver"
                              continue 
                          dato_suavizado = primera_derivada(dato)
                          descargar_csv_acotado(dato_suavizado,7) # 7 PARA SABER QUE VIENE DE ACA Y PODER ELEGIR EL NOMBRE DE LA CARPETA DE SALIDA
                      elif metodo_grafico == 7:
                          dato,nor_op,m_suavi = suavizado_menu_derivadas()
                          if dato is None:  # Manejar la opción "Volver"
                              continue 
                          dato_suavizado = primera_derivada(dato)
                          descargar_csv_tipo(dato_suavizado,7) # 7 PARA SABER QUE VIENE DE ACA Y PODER ELEGIR EL NOMBRE DE LA CARPETA DE SALIDA
                      elif metodo_grafico == 8:
                          dato,nor_op,m_suavi = suavizado_menu_derivadas()
                          if dato is None:  # Manejar la opción "Volver"
                              continue 
                          dato_suavizado = primera_derivada(dato)
                          descargar_csv_acotado_tipo(dato_suavizado,7) # 7 PARA SABER QUE VIENE DE ACA Y PODER ELEGIR EL NOMBRE DE LA CARPETA DE SALIDA
                      elif metodo_grafico == 9:
                          main()                     
        elif opcion == '8':           
                    print("sigue dentro")
                    while True:  # Bucle para mantener al usuario en el submenú
                      metodo = 8          
                      sub_menu()
                      metodo_grafico = int(input("Opcion: "))               
                      if metodo_grafico == 1:
                          dato,nor_op ,m_suavi = suavizado_menu_derivadas()
                          if dato is None:  # Manejar la opción "Volver"
                              continue # EVITA QUE CONTINUE LA EJECUCION DE LAS LINEAS RESTANTES Y SALTA AL SIGUIENTE CICLO
                          dato_suavizado = segunda_derivada(dato)
                          mostrar_espectros(dato_suavizado,raman_shift,metodo,nor_op,m_suavi,2)
                      elif metodo_grafico == 2:
                          dato,nor_op,m_suavi= suavizado_menu_derivadas()
                          if dato is None:  # Manejar la opción "Volver"
                              continue 
                          dato_suavizado = segunda_derivada(dato)
                          espectro_acotado(dato_suavizado,0,nor_op,m_suavi,2)
                      elif metodo_grafico == 3:
                          dato,nor_op,m_suavi = suavizado_menu_derivadas()
                          if dato is None:  # Manejar la opción "Volver"
                              continue 
                          dato_suavizado = segunda_derivada(dato)
                          grafico_tipo(dato_suavizado,raman_shift,nor_op,metodo,m_suavi,2)
                      elif metodo_grafico == 4:
                          dato,nor_op,m_suavi = suavizado_menu_derivadas()
                          if dato is None:  # Manejar la opción "Volver"
                              continue 
                          dato_suavizado = segunda_derivada(dato)
                          grafico_acotado_tipo(dato_suavizado,raman_shift,metodo,nor_op,m_suavi,2)
                      elif metodo_grafico == 5:
                          dato,nor_op,m_suavi = suavizado_menu_derivadas()
                          if dato is None:  # Manejar la opción "Volver"
                              continue 
                          dato_suavizado = segunda_derivada(dato)
                          descargar_csv(8, dato_suavizado) # 8 PARA SABER QUE VIENE DE LA SEGUNDA DERIVADA
                      elif metodo_grafico == 6:
                          dato,nor_op,m_suavi = suavizado_menu_derivadas()
                          if dato is None:  # Manejar la opción "Volver"
                              continue 
                          dato_suavizado = segunda_derivada(dato)
                          descargar_csv_acotado(dato_suavizado,8) # 8 PARA SABER QUE VIENE DE ACA Y PODER ELEGIR EL NOMBRE DE LA CARPETA DE SALIDA
                      elif metodo_grafico == 7:
                          dato,nor_op,m_suavi = suavizado_menu_derivadas()
                          if dato is None:  # Manejar la opción "Volver"
                              continue 
                          dato_suavizado = segunda_derivada(dato)
                          descargar_csv_tipo(dato_suavizado,8) # 8 PARA SABER QUE VIENE DE ACA Y PODER ELEGIR EL NOMBRE DE LA CARPETA DE SALIDA
                      elif metodo_grafico == 8:
                          dato,nor_op,m_suavi = suavizado_menu_derivadas()
                          if dato is None:  # Manejar la opción "Volver"
                              continue 
                          dato_suavizado = segunda_derivada(dato)
                          descargar_csv_acotado_tipo(dato_suavizado,8) # 8 PARA SABER QUE VIENE DE ACA Y PODER ELEGIR EL NOMBRE DE LA CARPETA DE SALIDA
                      elif metodo_grafico == 9:
                          main()     
        elif opcion == '9':
                      while True:  # Bucle para mantener al usuario en el submenú
                        metodo = 9          
                        sub_menu()
                        metodo_grafico = int(input("Opcion: "))               
                        if metodo_grafico == 1:
                            dato,nor_op ,m_suavi = menu_correccion()
                            if dato is None:  # Manejar la opción "Volver"
                                continue # EVITA QUE CONTINUE LA EJECUCION DE LAS LINEAS RESTANTES Y SALTA AL SIGUIENTE CICLO
                            dato_suavizado ,raman_shift_corregido = correcion_LineaB(dato) # RAMAN_SHIFT_CORREGIDO ES POR QUE YA SON ELIMANDOS LOS VALORES NAN
                            mostrar_espectros(dato_suavizado,raman_shift_corregido,metodo,nor_op,m_suavi,3)
                        elif metodo_grafico == 2:
                            dato,nor_op,m_suavi= menu_correccion()
                            if dato is None:  # Manejar la opción "Volver"
                                continue 
                            dato_suavizado = correcion_LineaB(dato)
                            espectro_acotado(dato_suavizado,0,nor_op,m_suavi,3)
                        elif metodo_grafico == 3:
                            dato,nor_op,m_suavi = menu_correccion()
                            if dato is None:  # Manejar la opción "Volver"
                                continue 
                            dato_suavizado = correcion_LineaB(dato)
                            grafico_tipo(dato_suavizado,raman_shift,nor_op,metodo,m_suavi,3)
                        elif metodo_grafico == 4:
                            dato,nor_op,m_suavi = menu_correccion()
                            if dato is None:  # Manejar la opción "Volver"
                                continue 
                            dato_suavizado = correcion_LineaB(dato)
                            grafico_acotado_tipo(dato_suavizado,raman_shift,metodo,nor_op,m_suavi,3)
                        elif metodo_grafico == 5:
                                dato,nor_op,m_suavi = menu_correccion()
                                if dato is None:  # Manejar la opción "Volver"
                                    continue 
                                dato_suavizado = correcion_LineaB(dato)
                                descargar_csv(9, dato_suavizado) # 9 PARA SABER QUE VIENE DE CORRECCION LINEAL
                        elif metodo_grafico == 6:
                            dato,nor_op,m_suavi = menu_correccion()
                            if dato is None:  # Manejar la opción "Volver"
                                continue 
                            dato_suavizado = correcion_LineaB(dato)
                            descargar_csv(9, dato_suavizado) # 9 PARA SABER QUE VIENE DE LA CORRECCION BASE LINEAL                          
                        elif metodo_grafico == 7:
                            dato,nor_op,m_suavi = menu_correccion()
                            if dato is None:  # Manejar la opción "Volver"
                                continue 
                            dato_suavizado = correcion_LineaB(dato)
                            descargar_csv_tipo(dato_suavizado,9) # 9 PARA SABER QUE VIENE DE ACA Y PODER ELEGIR EL NOMBRE DE LA CARPETA DE SALIDA
                        elif metodo_grafico == 8:
                            dato,nor_op,m_suavi = menu_correccion()
                            if dato is None:  # Manejar la opción "Volver"
                                continue 
                            dato_suavizado = correcion_LineaB(dato)
                            descargar_csv_acotado_tipo(dato_suavizado,9) # 9 PARA SABER QUE VIENE DE ACA Y PODER ELEGIR EL NOMBRE DE LA CARPETA DE SALIDA
                        elif metodo_grafico == 9:
                            main() 
                      
                      
                      
                      
                      
        elif opcion == '15':
            print("Saliendo del programa...")
            sys.exit()  # Termina completamente el programa
        else:
            print("Opción no válida. Inténtalo de nuevo.")


##ESTE CODIGO FUNCIONA PARA LAS OPCIONES 4,5,6 DE LOS SUAVIZADOS
def suavizado_menu():
    print("NORMALIZAR POR:")
    print("1-Media")
    print("2-Area")
    print("3-Sin normalizar")
    print("4- Volver")
    opcion = int(input("Selecciona una opción: "))
    
    if opcion == 1 :
        suavizar = normalizado_media()
    elif opcion == 2 :
        suavizar = normalizado_area()
    elif opcion == 3 :
        suavizar = datos_sin_normalizar()
    elif opcion == 4 :
        return None , None

    return suavizar , opcion


##ESTE CODIGO FUNCIONA PARA LAS OPCIONES 7.8 PARA LAS DERIVADAS
def suavizado_menu_derivadas():
   while True:  # Ciclo para permitir "Volver" sin salir de la función
        print("NORMALIZAR POR:")
        print("1- Media")
        print("2- Area")
        print("3- Sin normalizar")
        print("4- Volver")
        opcion = int(input("Selecciona una opción: "))
        
        if opcion == 1 :
            suavizar = normalizado_media()
        elif opcion == 2 :
            suavizar = normalizado_area()
        elif opcion == 3 :
            suavizar = datos_sin_normalizar()
        elif opcion == 4 :
            return None , None , None
        else:
            print("Opción no válida. Inténtalo de nuevo.")
            continue  # Regresa al inicio del ciclo

        while True:  # Submenú de suavizado
            print("DESEA SUAVIZAR")
            print("1. SI")
            print("2. NO")
            print("3. Volver")
            opcion_s =  int(input("OPCION: "))
            if opcion_s == 1:
                while True:  # Bucle para el submenú de suavizado
                    print("\n--- POR CUAL METODO DESEAS SUAVIZAR ---")
                    print("1- SUAVIZADO POR SAVIZTKY-GOLAY")
                    print("2- SUAVIZADO POR FILTRO GAUSIANO")
                    print("3- SUAVIZADO POR MEDIA MOVIL")
                    print("4- Volver")
                    metodo_suavizado = int(input("OPCION: "))
                    if metodo_suavizado == 1:
                        suavizar = suavizado_saviztky_golay(suavizar)
                        return suavizar , opcion , metodo_suavizado
                    elif metodo_suavizado == 2:
                        suavizar = suavizado_filtroGausiano(suavizar)
                        return suavizar , opcion , metodo_suavizado
                    elif metodo_suavizado == 3:
                        suavizar = suavizado_mediamovil(suavizar)   
                        return suavizar , opcion , metodo_suavizado
                    elif metodo_suavizado == 4:
                        break
                    else:
                        print("Opción no válida. Inténtalo de nuevo.")
            elif opcion_s == 2:
                metodo_suavizado = 5 # DEBO ASIGNAR UN VALOR A METODO_SUAVIZADO POR QUE EN CASO DE QUE NO QUIERA SUAVIZAR
                                     # IGUAL DEBE DE RETORNAR UN VALOR O DARA ERROR, PUSE 5 PARA QUE SABER QUE NO SE SUAVIZAO
                
                return suavizar , opcion , metodo_suavizado
            elif opcion_s == 3:
                break
            else: 
                print("Opción no válida. Inténtalo de nuevo.")
                continue
            


# ##ESTE CODIGO FUNCIONA PARA LAS OPCIONES 9,10 PARA LAS CORRECIONES
def menu_correccion():
    print("entrooooooooooooo")
    while True:  # Ciclo principal para manejar "Volver"
        print("NORMALIZAR POR:")
        print("1- Media")
        print("2- Área")
        print("3- Sin normalizar")
        print("4- Volver")
        
 
        opcion = int(input("Selecciona una opción: "))


        if opcion == 1:
            suavizar = normalizado_media()
        elif opcion == 2:
            suavizar = normalizado_area()
        elif opcion == 3:
            suavizar = datos_sin_normalizar()
        elif opcion == 4:
            return None, None, None
        else:
            print("Opción no válida. Inténtalo de nuevo.")
            continue

        opcion_s = 0
        while True:  # Submenú 
             if opcion_s == 3:
                 break
             while True:
                print("DESEA SUAVIZAR")
                print("1. Sí")
                print("2. No")
                print("3. Volver")
    
                opcion_s = int(input("Opción: "))
    
                if opcion_s == 1:
                    while True:  # Submenú de métodos de suavizado
                        print("\n--- POR CUAL METODO DESEAS SUAVIZAR ---")
                        print("1- Suavizado por Saviztky-Golay")
                        print("2- Suavizado por Filtro Gaussiano")
                        print("3- Suavizado por Media Móvil")
                        print("4- Volver")
                        
    
                        metodo_suavizado = int(input("Opción: "))
                        
    
                        if metodo_suavizado == 1:
                            suavizar = suavizado_saviztky_golay(suavizar)
                            break  # Lleva al menú de derivadas
                        elif metodo_suavizado == 2:
                            suavizar = suavizado_filtroGausiano(suavizar)
                            break  # Lleva al menú de derivadas
                        elif metodo_suavizado == 3:
                            suavizar = suavizado_mediamovil(suavizar)
                            break  # Lleva al menú de derivadas
                        elif metodo_suavizado == 4:
                            break  # Regresa al menú 
                        else:
                            print("Opción no válida. Inténtalo de nuevo.")
    
                    # Ir al menú de derivadas después del suavizado
                    while True:  # Submenú para derivadas
                        print("\n--- DESEA DERIVAR ---")
                        print("1- Derivar por Primera Derivada")
                        print("2- Derivar por Segunda Derivada")
                        print("3- No Derivar")
                        print("4- Volver")
    
                        opcion_d = int(input("Opción: "))
    
                        if opcion_d == 1:
                            derivada = primera_derivada(suavizar)
                            print("Primera derivada aplicada.")
                            return derivada, opcion, metodo_suavizado
                        elif opcion_d == 2:
                            derivada = segunda_derivada(suavizar)
                            print("Segunda derivada aplicada.")
                            return derivada, opcion, metodo_suavizado
                        elif opcion_d == 3:
                            print("No se aplicó derivada.")
                            derivada = suavizar  # Devolver el resultado suavizado sin derivar
                            return derivada, opcion, metodo_suavizado
                        elif opcion_d == 4:
                            print("Volviendo al menú '¿Desea suavizar?'.")
                            break  # Regresa al menú 
                        else:
                            print("Opción no válida. Inténtalo de nuevo.")
    
                elif opcion_s == 2:
                    metodo_suavizado = 5  # Valor para indicar que no se aplicó suavizado
                    
                    # Ir directamente al menú de derivadas
                    while True:
                        print("\n--- DESEA DERIVAR ---")
                        print("1- Derivar por Primera Derivada")
                        print("2- Derivar por Segunda Derivada")
                        print("3- No Derivar")
                        print("4- Volver")
                        
                        opcion_d = int(input("Opción: "))
    
                        if opcion_d == 1:
                            derivada = primera_derivada(suavizar)
                            return derivada, opcion, metodo_suavizado
                        elif opcion_d == 2:
                            derivada = segunda_derivada(suavizar)
                            return derivada, opcion, metodo_suavizado
                        elif opcion_d == 3:
                            derivada = suavizar  # Devolver el resultado suavizado sin derivar
                            return derivada, opcion, metodo_suavizado
                        elif opcion_d == 4:
                            break  # Regresa al menú 
                        else:
                            print("Opción no válida. Inténtalo de nuevo.")
    
                elif opcion_s == 3:
                    break  # Regresa al menú principal
                else:
                    print("Opción no válida. Inténtalo de nuevo.")
                    continue




def descargar_csv(normalizado,dato):
   
    df_aux = dato # obtenemos el dataframe              
    raman_shift_aux = raman_shift[:len(df_aux)] #nos aseguramos de que el tengan la misa longitud         
    df_aux.insert(0, '', raman_shift_aux)    # Insertamos la columna raman_shift en la posición 0
   
    if normalizado == 1:
        df.to_csv('output_sin_normalizar.csv', index=False, header=False)
        print("SE HA DESCARGADO EL ARCHIVO CON EL NOMBRE: output_sin_normalizar.csv")
    elif normalizado == 2:
        df_aux.to_csv('output_media.csv', index=False, header=True)# Guardarmos el DataFrame en un archivo CSV
        print("SE HA DESCARGADO EL ARCHIVO CON EL NOMBRE: output_media.csv")
    elif normalizado == 3:
        df_aux.to_csv('output_area.csv', index=False, header=True)# Guardarmos el DataFrame en un archivo CSV
        print("SE HA DESCARGADO EL ARCHIVO CON EL NOMBRE: output_area.csv")
    elif normalizado == 4:
        df_aux.to_csv('output_suavizado_saviztky_golay.csv', index=False, header=True)# Guardarmos el DataFrame en un archivo CSV
        print("SE HA DESCARGADO EL ARCHIVO CON EL NOMBRE: output_suavizado_saviztky_golay.csv")
    elif normalizado == 5:
        df_aux.to_csv('output_suavizado_filtro_gausiano.csv', index=False, header=True)# Guardarmos el DataFrame en un archivo CSV
        print("SE HA DESCARGADO EL ARCHIVO CON EL NOMBRE: output_suavizado_filtro_gausiano.csv")
    elif normalizado == 6:
        df_aux.to_csv('output_suavizado_media_movil.csv', index=False, header=True)# Guardarmos el DataFrame en un archivo CSV
        print("SE HA DESCARGADO EL ARCHIVO CON EL NOMBRE: output_suavizado_media_movil.csv")
    elif normalizado == 7:
        df_aux.to_csv('output_primera_derivada.csv', index=False, header=True)# Guardarmos el DataFrame en un archivo CSV
        print("SE HA DESCARGADO EL ARCHIVO CON EL NOMBRE: output_primera_derivada.csv")
    elif normalizado == 8:
        df_aux.to_csv('output_segunda_derivada.csv', index=False, header=True)# Guardarmos el DataFrame en un archivo CSV
        print("SE HA DESCARGADO EL ARCHIVO CON EL NOMBRE: output_segunda_derivada.csv")





def descargar_csv_acotado(datos, opcion):   # ESTA PARTE SE PUEDE OPTIMIZAR YA QUE 2-Grafico acotado  Y 6- Descargar .csv acotado por la media HACE LA MISMA COSA, SOLO QUE UNO GENERA UN .CSV Y EL OTRO LO GRAFICA
    df_aux = datos.to_numpy()
    print("PRINT")
    print(df_aux)
    cabecera_np = df.iloc[0, 1:].to_numpy()  # La primera fila contiene los encabezados
    #print("CABECERA_NP")
    #print(cabecera_np)
    intensidades_np = df_aux[:, :]  # Excluir la primera fila y primera columna
    #print("INTENSIDADES_NP")
    #print(intensidades_np)
    raman = df.iloc[1:, 0].to_numpy().astype(float)  # Primera columna (Raman Shift)
    #print("RAMAN")
    #print(raman)
    intensidades = intensidades_np.astype(float)  # Columnas restantes (intensidades)
    #print("INTENSIDADES")
    #print(intensidades)

    min_rango = int(input("Rango minimo: "))  
    max_rango = int(input("Rango maximo: "))  

    indices_acotados = (raman >= min_rango) & (raman <= max_rango)  
    #print("INDICES_ACOTADOS")
    #print(indices_acotados)
    #print(indices_acotados.shape)
    raman_acotado = raman[indices_acotados]
    #print("RAMAN_ACOTADO")
    #print(raman_acotado)
    intensidades_acotadas = intensidades[indices_acotados, :]
    #print("INTENSIDADES_ACOTADAS")
    #print(intensidades_acotadas)
    
    
    # Crear DataFrame filtrado
    df_acotado = pd.DataFrame(
        data=np.column_stack([raman_acotado, intensidades_acotadas]),
        columns=["Raman Shift"] + list(cabecera_np[:])  # Encabezados para el DataFrame
    )

    if opcion == 1:
        df_acotado.to_csv('output_acotado_sinNormalizar.csv', index=False, header=True)# Guardarmos el DataFrame en un archivo CSV
        print("SE HA DESCARGADO EL ARCHIVO CON EL NOMBRE: output_acotado_sinNormalizar.csv")
    elif opcion == 2:
        df_acotado.to_csv('output_acotado_media.csv', index=False, header=True)# Guardarmos el DataFrame en un archivo CSV
        print("SE HA DESCARGADO EL ARCHIVO CON EL NOMBRE: output_acotado_media.csv")
    elif opcion == 3:
        df_acotado.to_csv('output_acotado_area.csv', index=False, header=True)# Guardarmos el DataFrame en un archivo CSV
        print("SE HA DESCARGADO EL ARCHIVO CON EL NOMBRE: output_acotado_area.csv")
    elif opcion == 4:
        df_acotado.to_csv('output_acotado_suavizado_saviztky_golay.csv', index=False, header=True)# Guardarmos el DataFrame en un archivo CSV
        print("SE HA DESCARGADO EL ARCHIVO CON EL NOMBRE: output_acotado_suavizado_saviztky_golay.csv")
    elif opcion == 5:
        df_acotado.to_csv('output_acotado_filtro_gausiano.csv', index=False, header=True)# Guardarmos el DataFrame en un archivo CSV
        print("SE HA DESCARGADO EL ARCHIVO CON EL NOMBRE: output_acotado_filtro_gausiano.csv")
    elif opcion == 6:
        df_acotado.to_csv('output_acotado_media_movil.csv', index=False, header=True)# Guardarmos el DataFrame en un archivo CSV
        print("SE HA DESCARGADO EL ARCHIVO CON EL NOMBRE: output_acotado_media_movil.csv")
    elif opcion == 7:
        df_acotado.to_csv('output_acotado_primera_derivada.csv', index=False, header=True)# Guardarmos el DataFrame en un archivo CSV
        print("SE HA DESCARGADO EL ARCHIVO CON EL NOMBRE: output_acotado_primera_derivada.csv")
    elif opcion == 8:
        df_acotado.to_csv('output_acotado_segunda_derivada.csv', index=False, header=True)# Guardarmos el DataFrame en un archivo CSV
        print("SE HA DESCARGADO EL ARCHIVO CON EL NOMBRE: output_acotado_segunda_derivada.csv")
    elif opcion == 9:
        df_acotado.to_csv('output_acotado_corregido.csv', index=False, header=True)# Guardarmos el DataFrame en un archivo CSV
        print("SE HA DESCARGADO EL ARCHIVO CON EL NOMBRE: output_acotado_corregido.csv")
                            
        
        
        

def descargar_csv_tipo(datos,opcion):
    
    mostrar_tipo = input("Ingrese el tipo que deseas visualizar: ")

    columnas_eliminar = [] # GUARDAMOS EN ESTA LISTA TODO LO QUE SE VAS A ELIMINAR

    for col in datos.columns:
       
        if col != mostrar_tipo: # SI ESA COLUMNA NO CONINCIDE CON EL TIPO DESEADO SE AGREGAR EN columnas_eliminar
            columnas_eliminar.append(col)
    

    datos_filtrados = datos.drop(columns=columnas_eliminar) # CREAMOS UN DATAFRAME ELIMINANDO TODO LO QUE ESTE DENTRO DE columnas_eliminar
    
    datos_filtrados.insert(0, "raman_shift",raman_shift)  # Insertamos en la primera posición los valores de raman_shift
    #print("Datos filtrados con 'raman_shift' agregado:")
    #print(datos_filtrados)
        
    
    
    if opcion == 1:
        datos_filtrados.to_csv('output_tipo_sinNormalizar.csv', index=False, header=True)# Guardarmos el DataFrame en un archivo CSV
        print("SE HA DESCARGADO EL ARCHIVO CON EL NOMBRE: output_tipo_sinNormalizar.csv")
    elif opcion == 2:
        datos_filtrados.to_csv('output_tipo_media.csv', index=False, header=True)# Guardarmos el DataFrame en un archivo CSV
        print("SE HA DESCARGADO EL ARCHIVO CON EL NOMBRE: output_tipo_media.csv")
    elif opcion == 3:
        datos_filtrados.to_csv('output_tipo_area.csv', index=False, header=True)# Guardarmos el DataFrame en un archivo CSV
        print("SE HA DESCARGADO EL ARCHIVO CON EL NOMBRE: output_tipo_area.csv")
    elif opcion == 4:
        datos_filtrados.to_csv('output_tipo_suavizado_saviztky_golay.csv', index=False, header=True)# Guardarmos el DataFrame en un archivo CSV
        print("SE HA DESCARGADO EL ARCHIVO CON EL NOMBRE: output_tipo_suavizado_saviztky_golay.csv")
    elif opcion == 5:
        datos_filtrados.to_csv('output_tipo_suavizado_filtro_gausiano.csv', index=False, header=True)# Guardarmos el DataFrame en un archivo CSV
        print("SE HA DESCARGADO EL ARCHIVO CON EL NOMBRE: output_tipo_suavizado_filtro_gausiano.csv")
    elif opcion == 6:
        datos_filtrados.to_csv('output_tipo_suavizado_media_movil.csv', index=False, header=True)# Guardarmos el DataFrame en un archivo CSV
        print("SE HA DESCARGADO EL ARCHIVO CON EL NOMBRE: output_tipo_media_movil.csv")
    elif opcion == 7:
        datos_filtrados.to_csv('output_tipo_primera_derivada.csv', index=False, header=True)# Guardarmos el DataFrame en un archivo CSV
        print("SE HA DESCARGADO EL ARCHIVO CON EL NOMBRE: output_tipo_primera_derivada.csv")
    elif opcion == 8:
        datos_filtrados.to_csv('output_tipo_segunda_derivada.csv', index=False, header=True)# Guardarmos el DataFrame en un archivo CSV
        print("SE HA DESCARGADO EL ARCHIVO CON EL NOMBRE: output_tipo_segunda_derivada.csv")
    elif opcion == 9:
        datos_filtrados.to_csv('output_tipo_corregido.csv', index=False, header=True)# Guardarmos el DataFrame en un archivo CSV
        print("SE HA DESCARGADO EL ARCHIVO CON EL NOMBRE: output_tipo_corregido.csv")




def descargar_csv_acotado_tipo(datos,opcion):
   
    mostrar_tipo = input("Ingrese el tipo que deseas visualizar: ")


    columnas_eliminar = [] # GUARDAMOS EN ESTA LISTA TODO LO QUE SE VAS A ELIMINAR

    for col in datos.columns:
       
        if col != mostrar_tipo: # SI ESA COLUMNA NO CONINCIDE CON EL TIPO DESEADO SE AGREGAR EN columnas_eliminar
            columnas_eliminar.append(col)
    

    datos_filtrados = datos.drop(columns=columnas_eliminar) # CREAMOS UN DATAFRAME ELIMINANDO TODO LO QUE ESTE DENTRO DE columnas_eliminar
    
    datos_filtrados.insert(0, "raman_shift",raman_shift)  # Insertamos en la primera posición los valores de raman_shift
    #print("Datos filtrados con 'raman_shift' agregado:")
    #print(datos_filtrados)
    datos_filtrados = datos_filtrados.astype(object)  # Convierte todo el DataFrame a tipo object       
    df_aux = datos_filtrados.iloc[:,1:].to_numpy()
    #print("PRINT")
    #print(df_aux)
    datos_filtrados.iloc[0, 1:] = mostrar_tipo
    cabecera_np = datos_filtrados.iloc[0, 1:].to_numpy()  # La primera fila contiene los encabezados
    #print("CABECERA_NP")
    #print(cabecera_np)
    intensidades_np = df_aux[:, :]
    #print("INTENSIDADES_NP")
    #print(intensidades_np)
    raman = df.iloc[1:, 0].to_numpy().astype(float)  # Primera columna (Raman Shift)
    #print("RAMAN")
    #print(raman)
    intensidades = intensidades_np.astype(float)  # Columnas restantes (intensidades)
    # print("INTENSIDADES")
    # print(intensidades)
    
    min_rango = int(input("Rango minimo: "))  
    max_rango = int(input("Rango maximo: "))  
    
    indices_acotados = (raman >= min_rango) & (raman <= max_rango)  
    # print("INDICES_ACOTADOS")
    # print(indices_acotados)
    # print(indices_acotados.shape)
    raman_acotado = raman[indices_acotados]
    # print("RAMAN_ACOTADO")
    # print(raman_acotado)
    intensidades_acotadas = intensidades[indices_acotados, :]
    # print("INTENSIDADES_ACOTADAS")
    # print(intensidades_acotadas)
    
    # print("murio aca")
    
    # Crear DataFrame filtrado
    datos_acotado_tipo = pd.DataFrame(
        data=np.column_stack([raman_acotado, intensidades_acotadas]),
        columns=["Raman Shift"] + list(cabecera_np[:]) # Encabezados para el DataFrame
    )
    # print("datos_acotado_tipo ")
    # print(datos_acotado_tipo )
    
    if opcion == 1:
        datos_acotado_tipo.to_csv('output_acotado_tipo_sinNormalizar.csv', index=False, header=True)# Guardarmos el DataFrame en un archivo CSV
        print("SE HA DESCARGADO EL ARCHIVO CON EL NOMBRE: output_acotado_tipo_sinNormalizar.csv")
    elif opcion == 2:
        datos_acotado_tipo.to_csv('output_acotado_tipo_media.csv', index=False, header=True)# Guardarmos el DataFrame en un archivo CSV
        print("SE HA DESCARGADO EL ARCHIVO CON EL NOMBRE: output_acotado_tipo_media.csv")
    elif opcion == 3:
        datos_acotado_tipo.to_csv('output_acotado_tipo_area.csv', index=False, header=True)# Guardarmos el DataFrame en un archivo CSV
        print("SE HA DESCARGADO EL ARCHIVO CON EL NOMBRE: output_acotado_tipo_area.csv")
    elif opcion == 4:
        datos_acotado_tipo.to_csv('output_acotado_tipo_suavizado_saviztky_golay.csv', index=False, header=True)# Guardarmos el DataFrame en un archivo CSV
        print("SE HA DESCARGADO EL ARCHIVO CON EL NOMBRE: output_acotado_tipo_suavizado_saviztky_golay.csv")
    elif opcion == 5:
        datos_acotado_tipo.to_csv('output_acotado_tipo_suavizado_filtro_gaussiano.csv', index=False, header=True)# Guardarmos el DataFrame en un archivo CSV
        print("SE HA DESCARGADO EL ARCHIVO CON EL NOMBRE: output_acotado_tipo_suavizado_filtro_gaussiano.csv")
    elif opcion == 6:
        datos_acotado_tipo.to_csv('output_acotado_tipo_suavizado_media_movil.csv', index=False, header=True)# Guardarmos el DataFrame en un archivo CSV
        print("SE HA DESCARGADO EL ARCHIVO CON EL NOMBRE: output_acotado_tipo_suavizado_media_movil.csv")
    elif opcion == 7:
        datos_acotado_tipo.to_csv('output_acotado_tipo_primera_derivada.csv', index=False, header=True)# Guardarmos el DataFrame en un archivo CSV
        print("SE HA DESCARGADO EL ARCHIVO CON EL NOMBRE: output_acotado_tipo_primera_derivada.csv")
    elif opcion == 8:
        datos_acotado_tipo.to_csv('output_acotado_tipo_segunda_derivada.csv', index=False, header=True)# Guardarmos el DataFrame en un archivo CSV
        print("SE HA DESCARGADO EL ARCHIVO CON EL NOMBRE: output_acotado_tipo_segunda_derivada.csv")
    elif opcion == 9:
        datos_acotado_tipo.to_csv('output_acotado_tipo_corregido.csv', index=False, header=True)# Guardarmos el DataFrame en un archivo CSV
        print("SE HA DESCARGADO EL ARCHIVO CON EL NOMBRE: output_acotado_tipo_corregido.csv")




def mostrar_espectros(datos,raman_shift,metodo,nor_op,op_der,derivada): # LA VARIABLE DERIVADA ES  SOLO PARA SABER SI ES LA 1RA O LA 2DA
    
    
    #print("ENTRO EN MOSTRAR ESPECTROS")
    #print(datos)
    
    # Graficar los espectros
    if nor_op != 0:
        print("Procesando los datos")
        print("Por favor espere un momento...")
    
    plt.figure(figsize=(10, 6))
 
  
    leyendas_tipos = set()  # almacenamos los tipos que enocntramos y la funcion set() nos ayuda a quer no se repitan
    pos_y=0
    for col in datos.columns :
        #print('entro normal')
        #col agarrar el nombre de los tipos de cada columna
        for tipo in asignacion_colores:
            #print("wwwwwww")
            if tipo == col :
                color_actual= asignacion_colores[tipo] #ACA YA ENCONTRAMOS EL COLOR CORRESPONDIENTE A ESE TIPO   
                if isinstance(col, str):  #Verifica que el nombre de la columna sea un string
                    if tipo in leyendas_tipos:
                        plt.plot(raman_shift , datos[col], color=color_actual, alpha=0.5, linewidth = 0.1,label=col)   
                        break
                    else:
                        plt.plot(raman_shift , datos[col], color=color_actual, alpha=0.5, linewidth = 0.1) 
                        leyendas_tipos.add(tipo) 
                pos_y+=1 
    
    if op_der == 0:
        titulo_plot_mostrar(metodo,nor_op)

    if derivada == 1:
        titulo_plot_primera_derivada(nor_op,op_der)
    elif derivada == 2:
        titulo_plot_segunda_derivada(nor_op,op_der)
    elif derivada == 3:  # PARA QUE VAYA AL PLOT DE CORRECION DE LINEA BASE OPCION 9
        titulo_plot_correcion_base(nor_op,op_der)







def titulo_plot_mostrar(metodo,nor_op):
    # TODO ESTE CONDICIONAL ES SOLO PARA QUE EL TITULO DEL GRAFICO MUESTRE POR CUAL METODO SE NORMALIZO
    if metodo == 1:
        plt.xlabel('Longitud de onda / Frecuencia')
        plt.ylabel('Intensidad')
        plt.title(f'Espectros del archivo {bd_name}')
        plt.show()
    elif metodo == 2:
        plt.xlabel('Longitud de onda / Frecuencia')
        plt.ylabel('Intensidad')
        plt.title(f'Espectros del archivo {bd_name} Normalizado por la Media')
        plt.show()
    elif metodo == 3:
        plt.xlabel('Longitud de onda / Frecuencia')
        plt.ylabel('Intensidad')
        plt.title(f'Espectros del archivo {bd_name} Normalizado por Area')
        plt.show()
    elif metodo == 4:
        if nor_op == 1:
               plt.xlabel('Longitud de onda / Frecuencia')
               plt.ylabel('Intensidad')
               plt.title(f'Espectros del archivo {bd_name} Suavizado por Saviztky_golay y Normalizado por la media')
               plt.show()   
        elif nor_op == 2:
               plt.xlabel('Longitud de onda / Frecuencia')
               plt.ylabel('Intensidad')
               plt.title(f'Espectros del archivo {bd_name} Suavizado por Saviztky_golay y Normalizado Area')
               plt.show() 
        else:
               plt.xlabel('Longitud de onda / Frecuencia')
               plt.ylabel('Intensidad')
               plt.title(f'Espectros del archivo {bd_name} Suavizado por Saviztky_golay y sin Normalizar ')
               plt.show()  
    elif metodo == 5:
        if nor_op == 1:
               plt.xlabel('Longitud de onda / Frecuencia')
               plt.ylabel('Intensidad')
               plt.title(f'Espectros del archivo {bd_name} Suavizado por Filtro Gausiano y Normalizado por la media')
               plt.show()   
        elif nor_op == 2:
               plt.xlabel('Longitud de onda / Frecuencia')
               plt.ylabel('Intensidad')
               plt.title(f'Espectros del archivo {bd_name} Suavizado por Filtro Gausiano y Normalizado Area')
               plt.show() 
        else:
               plt.xlabel('Longitud de onda / Frecuencia')
               plt.ylabel('Intensidad')
               plt.title(f'Espectros del archivo {bd_name} Suavizado por Filtro Gausiano y sin Normalizar ')
               plt.show()  
    elif metodo == 6:
        if nor_op == 1:
               plt.xlabel('Longitud de onda / Frecuencia')
               plt.ylabel('Intensidad')
               plt.title(f'Espectros del archivo {bd_name} Suavizado por Media Movil y Normalizado por la media')
               plt.show()   
        elif nor_op == 2:
               plt.xlabel('Longitud de onda / Frecuencia')
               plt.ylabel('Intensidad')
               plt.title(f'Espectros del archivo {bd_name} Suavizado por Media Movil y Normalizado Area')
               plt.show() 
        else:
               plt.xlabel('Longitud de onda / Frecuencia')
               plt.ylabel('Intensidad')
               plt.title(f'Espectros del archivo {bd_name} Suavizado por Media Movil y sin Normalizar ')
               plt.show()  
                                
  
def titulo_plot_acotado(nor_op,min_rango,max_rango):
     if nor_op == 1:
         plt.xlabel('Longitud de onda / Frecuencia')
         plt.ylabel('Intensidad')
         plt.title(f'Espectros del archivo {bd_name} en el rango de {min_rango} a {max_rango}')
         plt.show()
     elif nor_op == 2:
         plt.xlabel('Longitud de onda / Frecuencia')
         plt.ylabel('Intensidad')
         plt.title(f'Espectros del archivo {bd_name} normalizado por la media en el rango de {min_rango} a {max_rango}')
         plt.show()
     elif nor_op == 3:
         plt.xlabel('Longitud de onda / Frecuencia')
         plt.ylabel('Intensidad')
         plt.title(f'Espectros del archivo {bd_name} normalizado por la area en el rango de {min_rango} a {max_rango}')
         plt.show() 
     elif nor_op == 4:
         plt.xlabel('Longitud de onda / Frecuencia')
         plt.ylabel('Intensidad')
         plt.title(f'Espectros del archivo {bd_name} Suavizado por Saviztky_golay y Normalizado por la media')
         plt.show()   
     elif nor_op == 5:
         plt.xlabel('Longitud de onda / Frecuencia')
         plt.ylabel('Intensidad')
         plt.title(f'Espectros del archivo {bd_name} Suavizado por Saviztky_golay y Normalizado Area')
         plt.show() 
     elif nor_op == 6:
         plt.xlabel('Longitud de onda / Frecuencia')
         plt.ylabel('Intensidad')
         plt.title(f'Espectros del archivo {bd_name} Suavizado por Saviztky_golay y sin Normalizar ')
         plt.show()  
     elif nor_op == 7:
         plt.xlabel('Longitud de onda / Frecuencia')
         plt.ylabel('Intensidad')
         plt.title(f'Espectros del archivo {bd_name} Suavizado por Filtro Gausiano y Normalizado por la media')
         plt.show()   
     elif nor_op == 8:
         plt.xlabel('Longitud de onda / Frecuencia')
         plt.ylabel('Intensidad')
         plt.title(f'Espectros del archivo {bd_name} Suavizado por Filtro Gausiano y Normalizado Area')
         plt.show() 
     elif nor_op == 9:
         plt.xlabel('Longitud de onda / Frecuencia')
         plt.ylabel('Intensidad')
         plt.title(f'Espectros del archivo {bd_name} Suavizado por Filtro Gausiano y sin Normalizar ')
         plt.show()  
     elif nor_op == 10:
         plt.xlabel('Longitud de onda / Frecuencia')
         plt.ylabel('Intensidad')
         plt.title(f'Espectros del archivo {bd_name} Suavizado por Media Movil y Normalizado por la media')
         plt.show()   
     elif nor_op == 11:
         plt.xlabel('Longitud de onda / Frecuencia')
         plt.ylabel('Intensidad')
         plt.title(f'Espectros del archivo {bd_name} Suavizado por Media Movil y Normalizado Area')
         plt.show() 
     elif nor_op == 12:
         plt.xlabel('Longitud de onda / Frecuencia')
         plt.ylabel('Intensidad')
         plt.title(f'Espectros del archivo {bd_name} Suavizado por Media Movil y sin Normalizar ')
         plt.show()      
         






def titulo_plot_tipo(metodo,mostrar_tipo,opcion,m_suavi):
    print("titulo_plot_tipo")
    # TODO ESTE CONDICIONAL ES SOLO PARA QUE EL TITULO DEL GRAFICO MUESTRE POR CUAL METODO SE NORMALIZO
    if metodo == 1:
        plt.xlabel('Longitud de onda / Frecuencia')
        plt.ylabel('Intensidad')
        plt.title(f'Espectro del tipo: {mostrar_tipo} del archivo {bd_name} sin normalizar')
        plt.show()
    elif metodo == 2:
        plt.xlabel('Longitud de onda / Frecuencia')
        plt.ylabel('Intensidad')
        plt.title(f'Espectro del tipo: {mostrar_tipo} del archivo {bd_name} Normalizado por la Media')
        plt.show()
    elif metodo == 3:
        plt.xlabel('Longitud de onda / Frecuencia')
        plt.ylabel('Intensidad')
        plt.title(f'Espectro del tipo: {mostrar_tipo} del archivo {bd_name} Normalizado por Area')
        plt.show()
    elif metodo == 4:
        if opcion == 1:
            plt.xlabel('Longitud de onda / Frecuencia')
            plt.ylabel('Intensidad')
            plt.title(f'Espectro del tipo: {mostrar_tipo}  Suavizado por Saviztky_golay y Normalizado por la media')
            plt.show()   
        elif opcion == 2:
            plt.xlabel('Longitud de onda / Frecuencia')
            plt.ylabel('Intensidad')
            plt.title(f'Espectro del tipo: {mostrar_tipo} Suavizado por Saviztky_golay y Normalizado Area')
            plt.show() 
        else:
            plt.xlabel('Longitud de onda / Frecuencia')
            plt.ylabel('Intensidad')
            plt.title(f'Espectro del tipo: {mostrar_tipo}  Suavizado por Saviztky_golay y sin Normalizar ')
            plt.show()          
    elif metodo == 5:
        if opcion == 1:
            plt.xlabel('Longitud de onda / Frecuencia')
            plt.ylabel('Intensidad')
            plt.title(f'Espectro del tipo: {mostrar_tipo}  Suavizado por Filtro Gaussiano y Normalizado por la media')
            plt.show()   
        elif opcion == 2:
            plt.xlabel('Longitud de onda / Frecuencia')
            plt.ylabel('Intensidad')
            plt.title(f'Espectro del tipo: {mostrar_tipo}  Suavizado por Filtro Gaussiano y Normalizado Area')
            plt.show() 
        else:
            plt.xlabel('Longitud de onda / Frecuencia')
            plt.ylabel('Intensidad')
            plt.title(f'Espectro del tipo: {mostrar_tipo} Suavizado por Filtro Gaussiano y sin Normalizar ')
            plt.show() 
    elif metodo == 6:
        if opcion == 1:
            plt.xlabel('Longitud de onda / Frecuencia')
            plt.ylabel('Intensidad')
            plt.title(f'Espectro del tipo: {mostrar_tipo}  Suavizado por Media Movil y Normalizado por la media')
            plt.show()   
        elif opcion == 2:
            plt.xlabel('Longitud de onda / Frecuencia')
            plt.ylabel('Intensidad')
            plt.title(f'Espectro del tipo: {mostrar_tipo}  Suavizado por Media Movil y Normalizado Area')
            plt.show() 
        else:
            plt.xlabel('Longitud de onda / Frecuencia')
            plt.ylabel('Intensidad')
            plt.title(f'Espectro del tipo: {mostrar_tipo}  Suavizado por Media Movil y sin Normalizar ')
            plt.show() 
    elif metodo == 7:
            print("hola PCA")
    elif metodo == 8:
            plt.xlabel('Longitud de onda / Frecuencia')
            plt.ylabel('Intensidad')
            plt.title(f'Espectro del tipo: {mostrar_tipo}  por la primera derivada ')
            plt.show() 
    elif metodo == 9:
            plt.xlabel('Longitud de onda / Frecuencia')
            plt.ylabel('Intensidad')
            plt.title(f'Espectro del tipo: {mostrar_tipo}  por la primera derivada ')
            plt.show() 
    elif metodo == 10:
            if opcion == '1':
                if m_suavi == 1:
                    plt.xlabel('Longitud de onda / Frecuencia')
                    plt.ylabel('Intensidad')
                    plt.title(f'Espectros del archivo {bd_name} Suavizado por SAVIZTKY-GOLAY y Normalizado por la media')
                    plt.show()
                elif m_suavi == 2:
                    plt.xlabel('Longitud de onda / Frecuencia')
                    plt.ylabel('Intensidad')
                    plt.title(f'Espectros del archivo {bd_name} Suavizado por FILTRO GAUSIANO y Normalizado por la media')
                    plt.show()
                elif m_suavi == 3:
                    plt.xlabel('Longitud de onda / Frecuencia')
                    plt.ylabel('Intensidad')
                    plt.title(f'Espectros del archivo {bd_name} Suavizado por MEDIA MOVIL y Normalizado por la media')
                    plt.show()
                else:
                    plt.xlabel('Longitud de onda / Frecuencia')
                    plt.ylabel('Intensidad')
                    plt.title(f'Espectros del archivo {bd_name} sin suavizar y Normalizado por la media')
                    plt.show()
            elif opcion == '2':
                if m_suavi == 1:
                    plt.xlabel('Longitud de onda / Frecuencia')
                    plt.ylabel('Intensidad')
                    plt.title(f'Espectros del archivo {bd_name} Suavizado por SAVIZTKY-GOLAY y Normalizado por Area')
                    plt.show()
                elif m_suavi == 2:
                    plt.xlabel('Longitud de onda / Frecuencia')
                    plt.ylabel('Intensidad')
                    plt.title(f'Espectros del archivo {bd_name} Suavizado por FILTRO GAUSIANO y Normalizado por Area')
                    plt.show()
                elif m_suavi == 3:
                    plt.xlabel('Longitud de onda / Frecuencia')
                    plt.ylabel('Intensidad')
                    plt.title(f'Espectros del archivo {bd_name} Suavizado por MEDIA MOVIL y Normalizado por Area')
                    plt.show()
                else:
                    plt.xlabel('Longitud de onda / Frecuencia')
                    plt.ylabel('Intensidad')
                    plt.title(f'Espectros del archivo {bd_name} sin Suavizar y Normalizado por Area')
                    plt.show()
            else:
                if m_suavi == 1:
                    plt.xlabel('Longitud de onda / Frecuencia')
                    plt.ylabel('Intensidad')
                    plt.title(f'Espectros del archivo {bd_name} Suavizado por SAVIZTKY-GOLAY y Sin Normalizar')
                    plt.show()
                elif m_suavi == 2:
                    plt.xlabel('Longitud de onda / Frecuencia')
                    plt.ylabel('Intensidad')
                    plt.title(f'Espectros del archivo {bd_name} Suavizado por FILTRO GAUSIANO y Sin Normalizar')
                    plt.show()
                elif m_suavi == 3:
                    plt.xlabel('Longitud de onda / Frecuencia')
                    plt.ylabel('Intensidad')
                    plt.title(f'Espectros del archivo {bd_name} Suavizado por MEDIA MOVIL y Sin Normalizar')
                    plt.show()
                else:
                    plt.xlabel('Longitud de onda / Frecuencia')
                    plt.ylabel('Intensidad')
                    plt.title(f'Espectros del archivo {bd_name} sin Suavizar y Sin Normalizar')
                    plt.show()
    # elif metodo == 11:
    # elif metodo == 12:
    elif metodo == 13:
            plt.xlabel('Longitud de onda / Frecuencia')
            plt.ylabel('Intensidad')
            plt.title(f'Espectros del archivo {bd_name} Acotado ')
            plt.show() 
    else:
        print("NO HAY GRAFICA DISPONIBLE PARA ESTA OPCION")

 




def titulo_plot_tipo_acotado(metodo,mostrar_tipo,min_rango,max_rango,m_suavi):
 print("titulo_plot_tipo_acotado")
 # TODO ESTE CONDICIONAL ES SOLO PARA QUE EL TITULO DEL GRAFICO MUESTRE POR CUAL METODO SE NORMALIZO
 if metodo == 1:
     plt.xlabel('Longitud de onda / Frecuencia')
     plt.ylabel('Intensidad')
     plt.title(f'Espectro del tipo: {mostrar_tipo} del archivo {bd_name} sin normalizar en el rango:[{min_rango},{max_rango}]')
     plt.show()
 elif metodo == 2:
     plt.xlabel('Longitud de onda / Frecuencia')
     plt.ylabel('Intensidad')
     plt.title(f'Espectro del tipo: {mostrar_tipo} del archivo {bd_name} Normalizado por la Media en el rango:[{min_rango},{max_rango}]')
     plt.show()
 elif metodo == 3:
     plt.xlabel('Longitud de onda / Frecuencia')
     plt.ylabel('Intensidad')
     plt.title(f'Espectro del tipo: {mostrar_tipo} del archivo {bd_name} Normalizado por Area en el rango:[{min_rango},{max_rango}]')
     plt.show()
 elif metodo == 4:
     if m_suavi == 1:
         plt.xlabel('Longitud de onda / Frecuencia')
         plt.ylabel('Intensidad')
         plt.title(f'Espectro del tipo: {mostrar_tipo}  Suavizado por Saviztky_golay y Normalizado por la media')
         plt.show()   
     elif m_suavi == 2:
         plt.xlabel('Longitud de onda / Frecuencia')
         plt.ylabel('Intensidad')
         plt.title(f'Espectro del tipo: {mostrar_tipo} Suavizado por Saviztky_golay y Normalizado Area')
         plt.show() 
     else:
         plt.xlabel('Longitud de onda / Frecuencia')
         plt.ylabel('Intensidad')
         plt.title(f'Espectro del tipo: {mostrar_tipo}  Suavizado por Saviztky_golay y sin Normalizar ')
         plt.show()          
 elif metodo == 5:
     if m_suavi == 1:
         plt.xlabel('Longitud de onda / Frecuencia')
         plt.ylabel('Intensidad')
         plt.title(f'Espectro del tipo: {mostrar_tipo}  Suavizado por Filtro Gaussiano y Normalizado por la media')
         plt.show()   
     elif m_suavi == 2:
         plt.xlabel('Longitud de onda / Frecuencia')
         plt.ylabel('Intensidad')
         plt.title(f'Espectro del tipo: {mostrar_tipo}  Suavizado por Filtro Gaussiano y Normalizado Area')
         plt.show() 
     else:
         plt.xlabel('Longitud de onda / Frecuencia')
         plt.ylabel('Intensidad')
         plt.title(f'Espectro del tipo: {mostrar_tipo} Suavizado por Filtro Gaussiano y sin Normalizar ')
         plt.show() 
 elif metodo == 6:
     if m_suavi == 1:
         plt.xlabel('Longitud de onda / Frecuencia')
         plt.ylabel('Intensidad')
         plt.title(f'Espectro del tipo: {mostrar_tipo}  Suavizado por Media Movil y Normalizado por la media')
         plt.show()   
     elif m_suavi == 2:
         plt.xlabel('Longitud de onda / Frecuencia')
         plt.ylabel('Intensidad')
         plt.title(f'Espectro del tipo: {mostrar_tipo}  Suavizado por Media Movil y Normalizado Area')
         plt.show() 
     else:
         plt.xlabel('Longitud de onda / Frecuencia')
         plt.ylabel('Intensidad')
         plt.title(f'Espectro del tipo: {mostrar_tipo}  Suavizado por Media Movil y sin Normalizar ')
         plt.show() 
 elif metodo == 7:
         print("hola PCA")
 elif metodo == 8:
         plt.xlabel('Longitud de onda / Frecuencia')
         plt.ylabel('Intensidad')
         plt.title(f'Espectro del tipo: {mostrar_tipo}  por la primera derivada ')
         plt.show() 
 elif metodo == 9:
         plt.xlabel('Longitud de onda / Frecuencia')
         plt.ylabel('Intensidad')
         plt.title(f'Espectro del tipo: {mostrar_tipo}  por la primera derivada ')
         plt.show() 
 elif metodo == 10:
         if opcion == '1':
             if m_suavi == 1:
                 plt.xlabel('Longitud de onda / Frecuencia')
                 plt.ylabel('Intensidad')
                 plt.title(f'Espectros del archivo {bd_name} Suavizado por SAVIZTKY-GOLAY y Normalizado por la media')
                 plt.show()
             elif m_suavi == 2:
                 plt.xlabel('Longitud de onda / Frecuencia')
                 plt.ylabel('Intensidad')
                 plt.title(f'Espectros del archivo {bd_name} Suavizado por FILTRO GAUSIANO y Normalizado por la media')
                 plt.show()
             elif m_suavi == 3:
                 plt.xlabel('Longitud de onda / Frecuencia')
                 plt.ylabel('Intensidad')
                 plt.title(f'Espectros del archivo {bd_name} Suavizado por MEDIA MOVIL y Normalizado por la media')
                 plt.show()
             else:
                 plt.xlabel('Longitud de onda / Frecuencia')
                 plt.ylabel('Intensidad')
                 plt.title(f'Espectros del archivo {bd_name} sin suavizar y Normalizado por la media')
                 plt.show()
         elif opcion == '2':
             if m_suavi == 1:
                 plt.xlabel('Longitud de onda / Frecuencia')
                 plt.ylabel('Intensidad')
                 plt.title(f'Espectros del archivo {bd_name} Suavizado por SAVIZTKY-GOLAY y Normalizado por Area')
                 plt.show()
             elif m_suavi == 2:
                 plt.xlabel('Longitud de onda / Frecuencia')
                 plt.ylabel('Intensidad')
                 plt.title(f'Espectros del archivo {bd_name} Suavizado por FILTRO GAUSIANO y Normalizado por Area')
                 plt.show()
             elif m_suavi == 3:
                 plt.xlabel('Longitud de onda / Frecuencia')
                 plt.ylabel('Intensidad')
                 plt.title(f'Espectros del archivo {bd_name} Suavizado por MEDIA MOVIL y Normalizado por Area')
                 plt.show()
             else:
                 plt.xlabel('Longitud de onda / Frecuencia')
                 plt.ylabel('Intensidad')
                 plt.title(f'Espectros del archivo {bd_name} sin Suavizar y Normalizado por Area')
                 plt.show()
         else:
             if m_suavi == 1:
                 plt.xlabel('Longitud de onda / Frecuencia')
                 plt.ylabel('Intensidad')
                 plt.title(f'Espectros del archivo {bd_name} Suavizado por SAVIZTKY-GOLAY y Sin Normalizar')
                 plt.show()
             elif m_suavi == 2:
                 plt.xlabel('Longitud de onda / Frecuencia')
                 plt.ylabel('Intensidad')
                 plt.title(f'Espectros del archivo {bd_name} Suavizado por FILTRO GAUSIANO y Sin Normalizar')
                 plt.show()
             elif m_suavi == 3:
                 plt.xlabel('Longitud de onda / Frecuencia')
                 plt.ylabel('Intensidad')
                 plt.title(f'Espectros del archivo {bd_name} Suavizado por MEDIA MOVIL y Sin Normalizar')
                 plt.show()
             else:
                 plt.xlabel('Longitud de onda / Frecuencia')
                 plt.ylabel('Intensidad')
                 plt.title(f'Espectros del archivo {bd_name} sin Suavizar y Sin Normalizar')
                 plt.show()
 # elif metodo == 11:
 # elif metodo == 12:
 elif metodo == 13:
         plt.xlabel('Longitud de onda / Frecuencia')
         plt.ylabel('Intensidad')
         plt.title(f'Espectros del archivo {bd_name} Acotado ')
         plt.show() 
 else:
     print("NO HAY GRAFICA DISPONIBLE PARA ESTA OPCION")




def titulo_plot_primera_derivada(opcion,metodo_suavizado):
    print("OPCION = ", opcion)
    print("METODO_SUAVIZADO = ", metodo_suavizado)
    if opcion == 1:
        if metodo_suavizado == 1:
            plt.xlabel('Longitud de onda / Frecuencia')
            plt.ylabel('Intensidad')
            plt.title(f'Primera Derivada del archivo {bd_name} Suavizado por Saviztky_golay y Normalizado por la media ')
            plt.show()
        elif metodo_suavizado == 2:
            plt.xlabel('Longitud de onda / Frecuencia')
            plt.ylabel('Intensidad')
            plt.title(f'Primera Derivada del archivo {bd_name} Suavizado por FILTRO GAUSIANO y Normalizado por la media ')
            plt.show()
        elif metodo_suavizado == 3:
            plt.xlabel('Longitud de onda / Frecuencia')
            plt.ylabel('Intensidad')
            plt.title(f'Primera Derivada  del archivo {bd_name} Suavizado por MEDIA MOVIL y Normalizado por la media ')
            plt.show()
        else:
            plt.xlabel('Longitud de onda / Frecuencia')
            plt.ylabel('Intensidad')
            plt.title(f'Primera Derivada  del archivo {bd_name} Sin Suavizar y Normalizado por la media ')
            plt.show()
    elif opcion == 2:
        if metodo_suavizado == 1:
            plt.xlabel('Longitud de onda / Frecuencia')
            plt.ylabel('Intensidad')
            plt.title(f'Primera Derivada  del archivo {bd_name} Suavizado por Saviztky_golay y Normalizado por Area ')
            plt.show()
        elif metodo_suavizado == 2:
            plt.xlabel('Longitud de onda / Frecuencia')
            plt.ylabel('Intensidad')
            plt.title(f'Primera Derivada del archivo {bd_name} Suavizado por FILTRO GAUSIANO y Normalizado por Area ')
            plt.show()
        elif metodo_suavizado == 3:
            plt.xlabel('Longitud de onda / Frecuencia')
            plt.ylabel('Intensidad')
            plt.title(f'Primera Derivada  del archivo {bd_name} Suavizado por MEDIA MOVIL y Normalizado por Area')
            plt.show()
        else:
            plt.xlabel('Longitud de onda / Frecuencia')
            plt.ylabel('Intensidad')
            plt.title(f'Primera Derivada  del archivo {bd_name} Sin Suavizar y Normalizado por Area')
            plt.show()
    else:
        if metodo_suavizado == 1:
            plt.xlabel('Longitud de onda / Frecuencia')
            plt.ylabel('Intensidad')
            plt.title(f'Primera Derivada del archivo {bd_name} Suavizado por Saviztky_golay y sin Normalizar')
            plt.show()
        elif metodo_suavizado == 2:
            plt.xlabel('Longitud de onda / Frecuencia')
            plt.ylabel('Intensidad')
            plt.title(f'Primera Derivada del archivo {bd_name} Suavizado por FILTRO GAUSIANO y sin Normalizar ')
            plt.show()
        elif metodo_suavizado == 3:
            plt.xlabel('Longitud de onda / Frecuencia')
            plt.ylabel('Intensidad')
            plt.title(f'Primera Derivada del archivo {bd_name} Suavizado por MEDIA MOVIL y sin Normalizar')
            plt.show()
        else:
            plt.xlabel('Longitud de onda / Frecuencia')
            plt.ylabel('Intensidad')
            plt.title(f'Primera Derivada del archivo {bd_name} Sin Suavizar y sin Normalizar')
            plt.show()









def titulo_plot_segunda_derivada(opcion,metodo_suavizado):
        
     if opcion == 1:
         if metodo_suavizado == 1:
             plt.xlabel('Longitud de onda / Frecuencia')
             plt.ylabel('Intensidad')
             plt.title(f'Segunda Derivada del archivo {bd_name} Suavizado por Saviztky_golay y Normalizado por la media ')
             plt.show()
         elif metodo_suavizado == 2:
             plt.xlabel('Longitud de onda / Frecuencia')
             plt.ylabel('Intensidad')
             plt.title(f'Segunda Derivada del archivo {bd_name} Suavizado por FILTRO GAUSIANO y Normalizado por la media ')
             plt.show()
         elif metodo_suavizado == 3:
             plt.xlabel('Longitud de onda / Frecuencia')
             plt.ylabel('Intensidad')
             plt.title(f'Segunda Derivada  del archivo {bd_name} Suavizado por MEDIA MOVIL y Normalizado por la media ')
             plt.show()
         else:
             plt.xlabel('Longitud de onda / Frecuencia')
             plt.ylabel('Intensidad')
             plt.title(f'Segunda Derivada  del archivo {bd_name} Sin Suavizar y Normalizado por la media ')
             plt.show()
     elif opcion == 2:
         if metodo_suavizado == 1:
             plt.xlabel('Longitud de onda / Frecuencia')
             plt.ylabel('Intensidad')
             plt.title(f'Segunda Derivada  del archivo {bd_name} Suavizado por Saviztky_golay y Normalizado por Area ')
             plt.show()
         elif metodo_suavizado == 2:
             plt.xlabel('Longitud de onda / Frecuencia')
             plt.ylabel('Intensidad')
             plt.title(f'Segunda Derivada del archivo {bd_name} Suavizado por FILTRO GAUSIANO y Normalizado por Area ')
             plt.show()
         elif metodo_suavizado == 3:
             plt.xlabel('Longitud de onda / Frecuencia')
             plt.ylabel('Intensidad')
             plt.title(f'Segunda Derivada  del archivo {bd_name} Suavizado por MEDIA MOVIL y Normalizado por Area')
             plt.show()
         else:
             plt.xlabel('Longitud de onda / Frecuencia')
             plt.ylabel('Intensidad')
             plt.title(f'Segunda Derivada  del archivo {bd_name} Sin Suavizar y Normalizado por Area')
             plt.show()
     else:
         if metodo_suavizado == 1:
             plt.xlabel('Longitud de onda / Frecuencia')
             plt.ylabel('Intensidad')
             plt.title(f'Segunda Derivada del archivo {bd_name} Suavizado por Saviztky_golay y sin Normalizar')
             plt.show()
         elif metodo_suavizado == 2:
             plt.xlabel('Longitud de onda / Frecuencia')
             plt.ylabel('Intensidad')
             plt.title(f'Segunda Derivada del archivo {bd_name} Suavizado por FILTRO GAUSIANO y sin Normalizar ')
             plt.show()
         elif metodo_suavizado == 3:
             plt.xlabel('Longitud de onda / Frecuencia')
             plt.ylabel('Intensidad')
             plt.title(f'Segunda Derivada del archivo {bd_name} Suavizado por MEDIA MOVIL y sin Normalizar')
             plt.show()
         else:
             plt.xlabel('Longitud de onda / Frecuencia')
             plt.ylabel('Intensidad')
             plt.title(f'Segunda Derivada del archivo {bd_name} Sin Suavizar y sin Normalizar')
             plt.show()
         



##### ver como solucionar el tema de los datos que tiran todo iguales sus graficos, 

def espectro_acotado(datos, pca_op,nor_op,op_der,derivada):
      
    df_aux = datos.to_numpy()
    #print("PRINT")
    #print(df_aux)
    cabecera_np = df.iloc[0, 1:].to_numpy()  # La primera fila contiene los encabezados
    #print("CABECERA_NP")
    #print(cabecera_np)
    intensidades_np = df_aux[:, :]  # Excluir la primera fila y primera columna
    #print("INTENSIDADES_NP")
    #print(intensidades_np)
    raman = df.iloc[1:, 0].to_numpy().astype(float)  # Primera columna (Raman Shift)
    #print("RAMAN")
    #print(raman)
    intensidades = intensidades_np.astype(float)  # Columnas restantes (intensidades)
    #print("INTENSIDADES")
    #print(intensidades)
    # Solicitar el rango
    min_rango = int(input("Rango minimo: "))  # Cambia según lo que necesites
    max_rango = int(input("Rango maximo: "))  # Cambia según lo que necesites
    
    if pca_op == 0:
        print("Procesando los datos")
        print("Por favor espere un momento...")
    
    # Filtrar los datos en el rango
    indices_acotados = (raman >= min_rango) & (raman <= max_rango)  # Filtra los índices
    #print("INDICES_ACOTADOS")
    #print(indices_acotados)
    #print(indices_acotados.shape)
    raman_acotado = raman[indices_acotados]
    #print("RAMAN_ACOTADO")
    #print(raman_acotado)
    intensidades_acotadas = intensidades[indices_acotados, :]
    #print("INTENSIDADES_ACOTADAS")
    #print(intensidades_acotadas)
    
    
    # Crear DataFrame filtrado
    df_acotado = pd.DataFrame(
        data=np.column_stack([raman_acotado, intensidades_acotadas]),
        columns=["Raman Shift"] + list(cabecera_np[:])  # Encabezados para el DataFrame
    )

  
    if pca_op == 0 or pca_op == 2:
   
        # Graficar los espectros
        plt.figure(figsize=(10, 6))
    
        #print("entro en el graficador")
        #DESCOMENTAR EL CODIGO DE ABAJO ESE ES MIO, EL DE ARRIBA ES CHATGPT  
         
        leyendas = set()  # almacenamos los tipos que enocntramos y la funcion set() nos ayuda a quer no se repitan
        pos_y=0
        for col in df_acotado.columns :
                #print('entro normal')
              for tipo in asignacion_colores:
    
                    if tipo == col :
                      color_actual= asignacion_colores[tipo] #ACA YA ENCONTRAMOS EL COLOR CORRESPONDIENTE A ESE TIPO   
    
                      if isinstance(col, str):  #Verifica que el nombre de la columna sea un string
    
                            if tipo in leyendas:
                                
                                #print("error 1")
                                plt.plot(raman_acotado , df_acotado[col], color=color_actual, alpha=0.6, linewidth = 0.1,label=col) 
                                '''raman_shift:LE PASAMOS TODAS LAS INTENSIDADES , df2[col]= LE PASAMOS TODAS LAS COLUMNAS CON EL MISMO TIPO'''
      
                                break
                            else:
                                #print("error 2")
                                #print(raman)
                                #print(df_acotado[col])
                                plt.plot(raman_acotado , df_acotado[col], color=color_actual, alpha=0.6, linewidth = 0.1) 
                                leyendas.add(tipo) 
                      pos_y+=1 
           
        if op_der == 0:
            titulo_plot_acotado(nor_op,min_rango,max_rango)


        if derivada == 1:
            titulo_plot_primera_derivada(nor_op,op_der)
        elif derivada == 2:
            titulo_plot_segunda_derivada(nor_op,op_der)


        
        
    else: 
        return df_acotado , raman_acotado # creo que no hace falta retornarn nada ya que si una funcion le llama seria solamente para graficarla y retorna tiene quw retornar tambien su raman_shift acotado





def titulo_plot_correcion_base(nor_op,metodo_suavizado):
    print("entro aca")
    if nor_op == 1:
        if metodo_suavizado == 1:
            print("correccopn xDDDD")
            plt.xlabel('Longitud de onda / Frecuencia')
            plt.ylabel('Intensidad')
            plt.title(f'Correccion Linea base del archivo {bd_name} Suavizado por Saviztky_golay y Normalizado por la media ')
            plt.show()
        elif metodo_suavizado == 2:
            plt.xlabel('Longitud de onda / Frecuencia')
            plt.ylabel('Intensidad')
            plt.title(f'Correccion Linea base  del archivo {bd_name} Suavizado por FILTRO GAUSIANO y Normalizado por la media ')
            plt.show()
        elif metodo_suavizado == 3:
            plt.xlabel('Longitud de onda / Frecuencia')
            plt.ylabel('Intensidad')
            plt.title(f'Correccion Linea base  del archivo {bd_name} Suavizado por MEDIA MOVIL y Normalizado por la media ')
            plt.show()
        else:
            plt.xlabel('Longitud de onda / Frecuencia')
            plt.ylabel('Intensidad')
            plt.title(f'Correccion Linea base del archivo {bd_name} Sin Suavizar y Normalizado por la media ')
            plt.show()
    elif nor_op  == 2:
        if metodo_suavizado == 1:
            plt.xlabel('Longitud de onda / Frecuencia')
            plt.ylabel('Intensidad')
            plt.title(f'Correccion Linea base del archivo {bd_name} Suavizado por Saviztky_golay y Normalizado por Area ')
            plt.show()
        elif metodo_suavizado == 2:
            plt.xlabel('Longitud de onda / Frecuencia')
            plt.ylabel('Intensidad')
            plt.title(f'Correccion Linea base  del archivo {bd_name} Suavizado por FILTRO GAUSIANO y Normalizado por Area ')
            plt.show()
        elif metodo_suavizado == 3:
            plt.xlabel('Longitud de onda / Frecuencia')
            plt.ylabel('Intensidad')
            plt.title(f'Correccion Linea base  del archivo {bd_name} Suavizado por MEDIA MOVIL y Normalizado por Area')
            plt.show()
        else:
            plt.xlabel('Longitud de onda / Frecuencia')
            plt.ylabel('Intensidad')
            plt.title(f'Correccion Linea base  del archivo {bd_name} Sin Suavizar y Normalizado por Area')
            plt.show()
    else:
        if metodo_suavizado == 1:
            plt.xlabel('Longitud de onda / Frecuencia')
            plt.ylabel('Intensidad')
            plt.title(f'Correccion Linea base  del archivo {bd_name} Suavizado por Saviztky_golay y sin Normalizar')
            plt.show()
        elif metodo_suavizado == 2:
            plt.xlabel('Longitud de onda / Frecuencia')
            plt.ylabel('Intensidad')
            plt.title(f'Correccion Linea base  del archivo {bd_name} Suavizado por FILTRO GAUSIANO y sin Normalizar ')
            plt.show()
        elif metodo_suavizado == 3:
            plt.xlabel('Longitud de onda / Frecuencia')
            plt.ylabel('Intensidad')
            plt.title(f'Correccion Linea base  del archivo {bd_name} Suavizado por MEDIA MOVIL y sin Normalizar')
            plt.show()
        else:
            plt.xlabel('Longitud de onda / Frecuencia')
            plt.ylabel('Intensidad')
            plt.title(f'Correccion Linea base  del archivo {bd_name} Sin Suavizar y sin Normalizar')
            plt.show()
        



def grafico_tipo(datos,raman_shift,nor_op,metodo,op_der,derivada):

    
    #print("ENTRO EN MOSTRAR ESPECTROS")
    #print(datos)
    
    mostrar_tipo = input("Ingrese el tipo que deseas visualizar: ")
    
    print("Procesando los datos")
    print("Por favor espere un momento...")
    
    # Graficar los espectros
    plt.figure(figsize=(10, 6))
 
  
    leyendas_tipos = set()  # almacenamos los tipos que enocntramos y la funcion set() nos ayuda a quer no se repitan
    pos_y=0
    for col in datos.columns :
        if col == mostrar_tipo:
            #print("tipo seleccionado:", col)
            for tipo in asignacion_colores:
                #print("wwwwwww")
                if tipo == col :
                    color_actual= asignacion_colores[tipo] #ACA YA ENCONTRAMOS EL COLOR CORRESPONDIENTE A ESE TIPO   
                    if isinstance(col, str):  #Verifica que el nombre de la columna sea un string
                        if tipo in leyendas_tipos:
                            plt.plot(raman_shift , datos[col], color=color_actual, alpha=0.3, linewidth = 0.1,label=col)   
                            break
                        else:
                            plt.plot(raman_shift , datos[col], color=color_actual, alpha=0.3, linewidth = 0.1) 
                            leyendas_tipos.add(tipo) 
                    pos_y+=1 
    if op_der == 0:
        titulo_plot_tipo(metodo,mostrar_tipo,nor_op,metodo)

    if derivada == 1:
        titulo_plot_primera_derivada(metodo,op_der)
    elif derivada == 2:
        titulo_plot_segunda_derivada(metodo,op_der)



def grafico_acotado_tipo(datos,raman_shift,metodo,opcion,op_der,derivada):
    
    mostrar_tipo = input("Ingrese el tipo que deseas visualizar: ")


    #print("ENTRO EN EL ESPECTRO ACOTADO")
    #print(datos)

    df_aux = datos.to_numpy()
        
    print("ENTRO EN EL ESPECTRO ACOTADO222")
    print(df_aux)
    print(df_aux.shape)
    
    cabecera_np = df.iloc[0,:].to_numpy()   # la primera fila contiene los encabezados
    cabecera_np = cabecera_np[1:]
    #print("la cabeceras son:")
    #print(cabecera_np)
    #print(cabecera_np.shape)
    
    
    intensidades_np = df_aux[: , :] # apartamos las intensidades
    #print("intensidades_np son:")
    #print(intensidades_np)
    #print(intensidades_np.shape)
    
    
    raman =  df.iloc[:, 0].to_numpy().astype(float)  # Primera columna (Raman Shift)
    raman = raman[1:]
    intensidades =  intensidades_np[:, 1:].astype(float)  # Columnas restantes (intensidades)
    # print("RAMAN:")
    # print(raman)
    # print(raman.shape)
    # print("INTENSIDADES:")
    # print(intensidades)
    # print(intensidades.shape)
    # Filtrado del rango de las intensidades
    min_rango = int(input("Rango minimo: "))  # Cambia según lo que necesites
    max_rango = int(input("Rango maximo: "))  # Cambia según lo que necesites
    
    
    print("Procesando los datos")
    print("Por favor espere un momento...")
    
    indices_acotados = (raman >= min_rango) & (raman <= max_rango) #retorna false o true para los que estan en el rango
    #print("Indices acotados")
    #print(indices_acotados)
    #print(indices_acotados.shape)
    
    raman_acotado = raman[indices_acotados]
    intensidades_acotadas = intensidades[indices_acotados,:]

    
        
    # # # Imprimir resultados
    # print("Raman Shift Acotado:")
    # print(raman_acotado)
    # print("\nIntensidades Acotadas:")
    # print(intensidades_acotadas)
        
    
    # Crear un DataFrame a partir de las dos variables
    df_acotado = pd.DataFrame(
    data=np.column_stack([raman_acotado, intensidades_acotadas]),
    columns=["Raman Shift"] + list(cabecera_np[1:])  # Encabezados para el DataFrame
    )

    # Mostrar el DataFrame resultante
    print("df_acotado")
    # df_acotado = pd.DataFrame(df_acotado)
    print(df_acotado)


   
    # Graficar los espectros
    plt.figure(figsize=(10, 6))
    
    #print("entro en el graficador")
    #DESCOMENTAR EL CODIGO DE ABAJO ESE ES MIO, EL DE ARRIBA ES CHATGPT  
         
    leyendas = set()  # almacenamos los tipos que enocntramos y la funcion set() nos ayuda a quer no se repitan
    pos_y=0
    for col in df_acotado.columns :
        if col == mostrar_tipo:
            for tipo in asignacion_colores:
                if tipo == col :
                    color_actual= asignacion_colores[tipo] #ACA YA ENCONTRAMOS EL COLOR CORRESPONDIENTE A ESE TIPO   
                    if isinstance(col, str):  #Verifica que el nombre de la columna sea un string
                        if tipo in leyendas:
                            #print("error 1")
                            plt.plot(raman_acotado , df_acotado[col], color=color_actual, alpha=0.6, linewidth = 0.1,label=col) 
                            '''raman_shift:LE PASAMOS TODAS LAS INTENSIDADES , df2[col]= LE PASAMOS TODAS LAS COLUMNAS CON EL MISMO TIPO'''
                            break
                        else:
                            #print("error 2")
                            #print(raman)
                            #print(df_acotado[col])
                            plt.plot(raman_acotado , df_acotado[col], color=color_actual, alpha=0.6, linewidth = 0.1) 
                            leyendas.add(tipo) 
                    pos_y+=1 
           
    print("llego a graficar pero falta el plot")
    if op_der == 0:
        titulo_plot_tipo_acotado(metodo,mostrar_tipo,min_rango,max_rango,opcion) #el 0 es por el m_suavi que no esta implementado aun
    if derivada == 1:
        titulo_plot_primera_derivada(opcion,op_der)
    elif derivada == 2:
        titulo_plot_segunda_derivada(opcion,op_der)




# SUAVIZADO POR SAVIZTKY-GOLAY

def suavizado_saviztky_golay(dato_suavizar):  #acordarse que se puede suavizar por la media, area y directo

    ventana = int(input("INGRESE EL VALOR DE LA VENTANA: "))
    orden = int(input("INGRESE EL VALOR DEL ORDEN: "))
            
    dato = dato_suavizar.to_numpy() #PASAMOS LOS DATOS A NUMPY POR QUE SAVGOL_FILTER USA SOLO NUMPY COMO PARAMETRO (PIERDE LA CABECERA DE TIPOS AL HACER ESTO)
    suavizado = savgol_filter(dato, window_length=ventana, polyorder=orden)
    suavizado_pd = pd.DataFrame(suavizado) # PASAMOS SUAVIZADO A PANDAS Y GUARDAMOS EN SUAVIZADO_PD
    suavizado_pd.columns = dato_suavizar.columns # AGREGAMOS LA CABECERA DE TIPOS
        
  
    
    return suavizado_pd





 
# SUAVIZADO POR FILTRO GAUSIANO

def suavizado_filtroGausiano(dato_suavizar):  #acordarse que se puede suavizar por la media, area y directo
   
    sigma = int(input("INGRESE EL VALOR DE SIGMA: ")) #Un valor mayor de sigma produce un suavizado más fuerte

    cabecera = df.iloc[[0]].copy() # EXTRAEMOS LA PRIMERA FILA 
    #print("avanzo")
    #print(pca_op)
    #print(type(normalizado))  
    #print(normalizado)
    dato = dato_suavizar.to_numpy() #PASAMOS LOS DATOS A NUMPY (PIERDE LA CABECERA DE TIPOS AL HACER ESTO)
    #print(dato)
    #print(type(dato))
    #print(dato.dtype)  # me tira que es  Object, eso quiere decir que el array numpy contiene datos que no son de un tipo numerico uniforme
    # por lo que tendremos que forza su conversion con astype(float)
    dato = np.array(dato, dtype=float)
    #print(dato)
    #print(dato.dtype)
    suavizado_gaussiano = gaussian_filter(dato,sigma=sigma)
    #print(suavizado_gaussiano)
    suavizado_gaussiano_pd = pd.DataFrame(suavizado_gaussiano)
    #print("xxxxxxxxxxxxxxxxxxxxxxxxxx")
    #print(suavizado_gaussiano_pd)
     
    suavizado_gaussiano_pd.columns = cabecera.iloc[0,1:].values #agregamos la cabecera 
    #print(suavizado_gaussiano_pd)
    #print("RRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRrr")
    
    return suavizado_gaussiano_pd




def suavizado_mediamovil(dato_suavizar):

    ventana = int(input("INGRESE EL VALOR DE LA VENTANA: "))
    normalizado = dato_suavizar

      
    suavizado_media_movil = pd.DataFrame()
    
    
    suavizado_media_movil = normalizado.rolling(window=ventana, center=True).mean() # mean() es para hallar el promedio
    
   
    return suavizado_media_movil
    
    
   # print(suavizado_media_movil)





def primera_derivada(datos):
            
    
    df_derivada = datos.apply(pd.to_numeric, errors='coerce') # PASAMOS A NUMERICO SI ES NECESARIO
    #print("xXXXXXXXxxXXXX")
    #print(df_derivada)
    
    # Calcular la primera derivada
    df_derivada_diff = df_derivada.diff()
    
    # Imprimir la primera derivada
    #print("Primera Derivada:")
    #print(df_derivada_diff)
    

    return df_derivada_diff
    #para la llamada del PCA



def segunda_derivada(datos):
    
    df_derivada = datos.apply(pd.to_numeric, errors='coerce') # PASAMOS A NUMERICO SI ES NECESARIO
    #print("xXXXXXXXxxXXXX")
    #print(df_derivada)
    
    # Calcular la primera derivada
    df_derivada_diff = df_derivada.diff()
    #print("primera derivada")
    #print(df_derivada_diff)
    # Calculamos la segunda derivada
    df_derivada_diff = df_derivada_diff.diff()
    #print("segunda derivada")
    #print(df_derivada_diff)
    # Imprimir la primera derivada
    #print("Primera Derivada:")
    #print(df_derivada_diff)
    return df_derivada_diff
                        



# # # POR EL METODO DE REGRESION LINEAL
def correcion_LineaB(dato):
    print("NORMALIZADO-F")
    print(dato)
    cabecera_aux = dato.columns
    np_corregido = dato.to_numpy()
    df_corregido = pd.DataFrame(np_corregido)

    pendientes = {}
    intersecciones = {}
    y_ajustados = {}

    # Definir Raman Shift
    raman_shift = df_corregido.iloc[:, 0]
    raman_shift = pd.to_numeric(raman_shift, errors='coerce').dropna()  # Asegurarse de que sea numérico y sin NaN

    for col in df_corregido.columns:
        intensidades = df_corregido[col]
        intensidades = pd.to_numeric(intensidades, errors='coerce').dropna()

        # Crear una máscara para limpiar ambos arrays
        mask = ~np.isnan(raman_shift) & ~np.isnan(intensidades) & ~np.isinf(raman_shift) & ~np.isinf(intensidades)
        raman_shift_clean = raman_shift[mask]
        intensidades_clean = intensidades[mask]

        # # Validar si los datos son suficientes para np.polyfit
        # if len(raman_shift_clean) < 2 or len(intensidades_clean) < 2:
        #     print(f"Datos insuficientes para realizar el ajuste en la columna {col}.")
        #     continue

        # Ajustar polinomio de grado 1
        try:
            coef = np.polyfit(raman_shift_clean, intensidades_clean, 1)
        except np.linalg.LinAlgError as e:
            print(f"Error en np.polyfit para la columna {col}: {e}")
            coef = [0, 0]  # Coeficientes por defecto en caso de error

        pendiente = coef[0]
        interseccion = coef[1]
        pendientes[col] = pendiente
        intersecciones[col] = interseccion

        # Calcular y ajustado
        y_ajustado = pendiente * raman_shift_clean + interseccion
        y_ajustados[col] = intensidades_clean - y_ajustado

    df_y_ajustados = pd.DataFrame(y_ajustados)
    df_y_ajustados.columns = cabecera_aux
    print("LLEGO HASTA ACA")
    print(df_y_ajustados)
    return df_y_ajustados , raman_shift

# def correcion_shirley(normalizado, pca_op) :
#     print("FALTA IMPLEMENTEAR")
    





















if __name__ == "__main__":
     main()


