#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Fri Jan 10 08:40:54 2025

@author: diego
"""

# main.py
import os
import numpy as np
import pandas as pd
import csv # PARA ENCONTRAR EL TIPO DE DELIMITADOR DEL ARCHIVO .CSV
import re # PARA LA EXPRECION REGULAR DE LOS SUFIJOS
import time
import matplotlib
import matplotlib.pyplot as plt
import matplotlib.colors as mcolors
from sklearn.preprocessing import StandardScaler # PARA LA NORMALIZACION POR LA MEDIA 
from sklearn.decomposition import PCA
from scipy.signal import savgol_filter # Para suavizado de Savitzky Golay
from scipy.ndimage import gaussian_filter # PARA EL FILTRO GAUSSIANO
from sklearn.cluster import AgglomerativeClustering
from scipy.cluster.hierarchy import linkage, cut_tree, dendrogram


pila = []

def archivo_existe(ruta_archivo):
    # print("Buscando archivo.")
    # time.sleep(3)
    # print("Buscando archivo..")
    # time.sleep(2)
    print("Buscando archivo...")
    time.sleep(1)
    return os.path.isfile(ruta_archivo)

nombre = input("Por favor, ingresa tu nombre: ")
print(f"Hola, {nombre}!")

existe = False
archivo_nombre = input("Ingrese el nombre del archivo: ")

 

# Función para detectar el delimitador automáticamente por que los archivos pueden estar ceparados por , o ; etc
def identificar_delimitador(archivo):
    with open(archivo, 'r') as file:
        muestra_csv = file.read(4096)  # Lee una muestra de 4096 bytes
        #print("LA MUESTRA DEL CSV ES:")
        #print(muestra_csv)
        caracter = csv.Sniffer()
        delimitador = caracter.sniff(muestra_csv).delimiter
    return delimitador




def detectar_labels(df): #Detecta si los labels están en la fila o en la columna para ver si hacemos la transpuesta  o no

    # Verificar la primera fila (si contiene strings)
    if df.iloc[0].apply(lambda x: isinstance(x, str)).all():
        return "fila" #si los labels están en la primera fila
    
    # Verificar la primera columna (si contiene strings)
    elif df.iloc[:, 0].apply(lambda x: isinstance(x, str)).all():
        return "columna" #si los labels están en la primera columna
    
    # Si no hay etiquetas detectadas
    return "ninguno" #si no se detectan labels.



while existe == False:   
    if archivo_existe(archivo_nombre):  
        # print("Encontrado!.")
        # print("Analizando archivo.")
        # time.sleep(3)
        # print("Analizando archivo..")
        # time.sleep(2)
        # print("Analizando archivo...")
        time.sleep(1)
        bd_name = archivo_nombre #Este archivo contiene los datos espectroscópicos que serán leídos
        delimitador = identificar_delimitador(bd_name)
        print("EL DELIMITADOR ES: ", delimitador)
        df = pd.read_csv(bd_name, delimiter = delimitador , header=None)
        pila.append(df.copy())
        existe = True
        if detectar_labels(df) == "columna" :
            print("SE HIZO LA TRASPUESTA")
            df = df.T
        else:
            print("NO SE HIZO LA TRANSPUESTA")
    else:
        print("El archivo no existe.")
        archivo_nombre = input("Ingrese el nombre del archivo: ")

# print("DF ANTES DEL CORTE")
# print(df)
# print(df.shape)

# print("LOGRO LEER EL ARCHIVO")


def columna_con_menor_filas(df):
    
    # Calcular el número de valores no nulos en cada columna
    valores_no_nulos = df.notna().sum()
    
    # Encontrar la columna con la menor cantidad de valores no nulos
    columna_menor = valores_no_nulos.idxmin()
    cantidad_menor = valores_no_nulos.min()
    
    return columna_menor, cantidad_menor


col,fil = columna_con_menor_filas(df)
if len(df) == fil:
    print("EL DATASET TIENE LA MISMA CANTIDAD DE FILAS EN CADA COLUMNA")
else:
    print("LA COLUMNA CON MENOR CANTIDAD DE DATOS ES:")
    print("TIPO: ",df.iloc[0,col+1])
    print("FILA: ",fil)
    print("COLUMNA: ",col+1)   
    print("DIMENSION DEL DATAFRAME", df.shape)
    opcion = 0
    while opcion != 6:
        print("COMO DESEAS ARREGLAR EL DATAFRAME")
        print("1- ELIMINAR TODAS LAS FILAS HASTA IGUALAR A LA MENOR")
        print("2- ELIMINAR LA COLUMNA CON MENOR NUMERO DE FILAS")
        print("3- VER DATAFRAME ACTUAL")
        print("4- VOLVER ATRAS")
        print("5- GENERAR .CSV")
        print("6- SALIR")
        opcion= int(input("OPCION: "))
        
        if opcion == 1:
            
            menor_cant_filas = df.dropna().shape[0] # Buscamos la columna con menor cantidad de intensidades
            # print("menor cantidad de filas:", menor_cant_filas)
    
            df_truncado = df.iloc[:menor_cant_filas] # Hacemos los cortes para igualar las columnas
    
            df = df_truncado
            
            pila.append(df.copy())
            # print(df.shape)
        elif opcion == 2:
            # print(df.shape)
            df.drop(columns=[col], inplace=True)
            # print(df.shape)
            pila.append(df.copy())
        elif opcion == 3:
            print(df)
        elif opcion == 4:
             if pila:
                 # Recuperar el último estado del DataFrame
                 df = pila.pop()
                 print("Se ha revertido al estado anterior.")
             else:
                 print("No hay acciones para deshacer.")
    
        elif opcion == 5:
            df.to_csv('output.csv', index=False, header=0)
        else:
            print("Saliendo")
        



# renombramos la celda [0,0]

# print("Cambiar a cero: ",df.iloc[0,0])

df.iloc[0,0] = float(0)

# print("Cambiar a cero: ",df.iloc[0,0])

#print(df)



# HACEMOS LA ELIMINACION DE LOS SUFIJOS EN CASO DE TENER


for col in df.columns:
    valor = re.sub(r'[_\.]\d+$', '', str(df.at[0, col]).strip())  # Eliminar sufijos con _ o .
    try:
        df.at[0, col] = float(valor)  # Convertir de nuevo a float si es posible
    except ValueError:
        df.at[0, col] = valor  # Mantener como string si no es convertible


# print("Luego de eliminar los sufijos")
print(df)



##### PENSAR EN COMO HACER LA OPCION DE IR HACIA ATRAS Y DE GENERAR .CSV PARA DESCARGAR

def mostrar_menu():
      print("\n--- Menú Principal ---")
      print("1. MOSTRAR ESPECTROS")
      print("2. NORMALIZAR POR MEDIA")
      print("3. NORMALIZAR POR AREA")
      print("4. SUAVIZADO POR SAVIZTKY-GOLAY")
      print("5. SUAVIZADO POR FILTRO GAUSIANO")
      print("6. SUAVIZADO POR MEDIA MOVIL")
      print("7. PCA")
      print("8. PRIMERA DERIVADA")
      print("9. SEGUNDA DERIVADA")
      print("10. CORRECCION BASE LINEAL")
      print("11. CORRECION SHIRLEY")
      print("12. GRAFICO DE LOADINGS")
      print("13. ESPECTRO ACOTADO")
      print("14. GRAFICO HCA")
      print("15. Salir")
      
raman_shift = df.iloc[1:, 0].reset_index(drop=True)  # EXTRAEMOS TODA LA PRIMERA COLUMNA, reset_index(drop=True) SIRVE PARA QUE EL INDICE COMIENCE EN 0 Y NO EN 1
print(raman_shift)

tipos = df.iloc[0, 1:] # EXTRAEMOS LA PRIMERA FILA MENOS DE LA PRIMERA COLUMNA
#print(tipos)
cant_tipos = tipos.nunique() # PARA EL EJEMPLO DE LIMPIO.CSV CANT_TIPOS TENDRA VALOR 4 YA QUE HAY 4 TIPOS (collagen,lipids,glycogen,DNA)
#print(cant_tipos)
tipos_nombres = df.iloc[0, 1:].unique() # OBTENEMOS LOS NOMBRES DE LOS TIPOS
#print(tipos_nombres)

# Seleccionar un colormap distintivo
cmap = plt.cm.Spectral  # Puedes probar con "hsv", "Set3", "Spectral", etc.

#cmap = plt.colormaps['hsv']  # Usamos solo el nombre del colormap, Obtenemos el colormap sin especificar el número de colores

# Nos aseguramos de que `colores` es una lista
colores = [cmap(i) for i in np.linspace(0, 1, len(tipos_nombres))]  # Genera una lista de colores

# Crear el diccionario de asignación de colores
asignacion_colores = {tipo: mcolors.to_hex(colores[i]) for i, tipo in enumerate(tipos_nombres)}
#print(asignacion_colores)

diccionario=pd.DataFrame(asignacion_colores.items())
 #print(diccionario)



# MOSTRAMOS LA LEYENDA PARA CADA TIPO
plt.figure(figsize=(2,2))    
for index, row in diccionario.iterrows():
    #print('entro 15')
    tipo = row[0]   # Nombre del tipo (por ejemplo, 'collagen')
    color = row[1]  # Color asociado (por ejemplo, '#ff0000')
    plt.plot([], [], color=color, label=tipo) 
# Mostrar la leyenda y el gráfico
#print('entro 20')
plt.legend(loc='center')
plt.grid(False)
plt.title(f'Cantidad de tipos encontrados {cant_tipos}')
plt.axis('off')
plt.show()




def datos_sin_normalizar():
        
    df2 = df.copy()
    df2.columns = df2.iloc[0]
    #print(df2)
    df2 = df2.drop(0).reset_index(drop=True) #eliminamos la primera fila
    df2 = df2.drop(df2.columns[0], axis=1) #eliminamos la primera columna el del rama_shift
    #print(df2) # aca ya tenemos la tabla de la manera que necesitamos, fila cero es la cabecera con los nombres de los tipos anteriormente eran indice numericos consecutivos
    df2 = df2.apply(pd.to_numeric, errors='coerce') #CONVERTIMOS A NUMERICO
    #print("EL DATAFRAME DEL ESPECTRO SIN NORMALIZAR ES")
    #print(df2) #ESTA VARIABLE SE USA PARA EL PCA TAMBIEN
    #print(df2.shape)
    # print("DF22222")
    # print(df2)
    return df2


"""
VARIABLES DE NORMALIZAR POR LA MEDIA    tratar de hacer por la forma del ejemplo y no por z-core para ver si se soluciona lo de la raya
"""
def normalizado_media():
        
    intensity = df.iloc[1:, 1:] # EXTRAEMOS TODAS DEMAS COLUMNAS EXCEPTO LA PRIMERA FILA Y PRIMERA COLUMNA
    #print(intensity)     
    cabecera = df.iloc[[0]].copy() # EXTRAEMOS LA PRIMERA FILA 
    #print(cabecera)
    #print(cabecera.shape)
    scaler = StandardScaler() 
    cal_nor = scaler.fit_transform(intensity) #calcula la media y desviación estándar
    #print(cal_nor)
    dato_normalizado = pd.DataFrame(cal_nor, columns=intensity.columns) # lo convertimos de vuelta en un DataFrame
    #print(dato_normalizado)
    df_concatenado = pd.concat([cabecera,dato_normalizado], axis=0, ignore_index=True)
    #print(df_concatenado)
    #  Convertimos la primera fila en cabecera
    df_concatenado.columns = df_concatenado.iloc[0]  # Asigna la primera fila como nombres de columna
    # Eliminamos la primera fila (ahora es la cabecera) y reseteamos el índice
    df_concatenado_cabecera_nueva = df_concatenado[1:].reset_index(drop=True)
    #print(df_concatenado_cabecera_nueva.head(50))
    df_media_pca= pd.DataFrame(df_concatenado_cabecera_nueva.iloc[:,1:])
    #print("EL ESPECTRO NORMALIZADO POR LA MEDIA ES")
    #print(df_media_pca) #ESTA VARIABLE SE USA PARA EL PCA TAMBIEN
    #print('normalizacion media')
    #df_media_pca.to_csv("nor_media_df.csv", index=False)
    return  df_media_pca


"""
VARIABLES DE NORMALIZAR POR AREA    tratar de hacer otro sin np.trap para ver si se soluciona lo de la raya
"""
def normalizado_area():
    
    intensity = df.iloc[1:, 1:] # EXTRAEMOS TODAS DEMAS COLUMNAS EXCEPTO LA PRIMERA FILA Y PRIMERA COLUMNA
    #print(intensity)  
    
    cabecera = df.iloc[[0]].copy() # EXTRAEMOS LA PRIMERA FILA 
    #print(cabecera)
    
    df3 = pd.DataFrame(intensity)
    #print("DataFrame de Intensidades:")
    #print(df3)
    df3 = df3.apply(pd.to_numeric, errors='coerce')  # Convierte a numérico, colocando NaN donde haya problemas
    #print(df3)
    np_array = raman_shift.astype(float).to_numpy() #CONVERTIMOS INTENSITY AL TIPO NUMPY POR QUE POR QUE NP.TRAPZ UTILIZA ESE TIPO DE DATOS
    #print("valor de np_array: ")
    #print(np_array)
    
    df3_normalizado = df3.copy()
    #print("EL VALOR DE DF3 ES :")
    #print(df3)
    # Cálculamos el área bajo la curva para cada columna
    #print("\nÁreas bajo la curva para cada columna:")
    for col in df3.columns:
        #print(df3[col])
        #print(df3_normalizado[col])
        
        # np.trapz para hallar el area bajo la curva por el metodo del trapecio
        area = (np.trapz(df3[col], np_array)) *-1  #MULTIPLIQUE POR -1 PARA QUE EL GRAFICO SALGA TODO HACIA ARRIBA ESTO SE DEBE A QUE EL RAMAN_SHIFT ESTA EN FORMA DECRECIENTE
        if area != 0:
            df3_normalizado[col] = df3[col] / area
        else:
            print(f"Advertencia: El área de la columna {col} es cero y no se puede normalizar.") #seguro contra errores de división por cero 
    #print(df3_normalizado)
    df_concatenado_area = pd.concat([cabecera,df3_normalizado], axis=0, ignore_index=True)
    #print(df_concatenado_area)
    # Paso 1: Convertir la primera fila en cabecera
    df_concatenado_area.columns = df_concatenado_area.iloc[0]  # Asigna la primera fila como nombres de columna
    # Paso 2: Eliminar la primera fila (ahora es la cabecera) y resetear el índice
    df_concatenado_cabecera_nueva_area = df_concatenado_area[1:].reset_index(drop=True)
    # AHORA ELIMINAMOS LA COLUMNA CON VALORES NAN
    df_concatenado_cabecera_nueva_area = df_concatenado_cabecera_nueva_area.dropna(axis=1, how='all')
    #print("ESPECTRO NORMALIZADO POR EL AREA")
    #print(df_concatenado_cabecera_nueva_area) #ESTA VARIABLE SE USA PARA EL PCA TAMBIEN
    #print('entro 10')
    #df_concatenado_cabecera_nueva_area.to_csv("nor_area_df.csv", index=False)
    return df_concatenado_cabecera_nueva_area



'''
    PREPARAMOS EL SIGUIENTE MENU
'''


def main():
    while True:
        mostrar_menu()
        opcion = input("Selecciona una opción: ")
        
        if opcion == '1':
            
            metodo = 1
            print("Como deseas ver el espectro")
            print("1- Grafico completo") #ok
            print("2- Grafico acotado") #ok
            print("3- Grafico por tipo") #ok
            print("4- Grafico acotado por tipo") #ok
            print("5- Descargar .csv sin normalizar") #ok
            print("6- Descargar .csv acotado sin normalizar") #ok
            print("7- Descargar .csv por tipo") #ok
            print("8- Descargar .csv acotado por tipo")
            print("9- Volver") #ok
            metodo_grafico = int(input("Opcion: "))
            if metodo_grafico == 1:
                print("Procesando los datos")
                print("Por favor espere un momento...")
                mostrar_espectros(datos_sin_normalizar(),raman_shift,metodo)
            elif metodo_grafico == 2:
                espectro_acotado(datos_sin_normalizar(), 0,1)
            elif metodo_grafico == 3:
                grafico_tipo(datos_sin_normalizar(),raman_shift,metodo)
            elif metodo_grafico == 4:
                grafico_acotado_tipo(datos_sin_normalizar(),raman_shift,metodo)
            elif metodo_grafico == 5: 
                descargar_csv(1) # 1 PARA SABER QUE VIENE SIN NORMALIZAR                
            elif metodo_grafico == 6:
                descargar_csv_acotado(datos_sin_normalizar(),1) # 1 PARA SABER QUE VIENE DE ACA Y PODER ELEGIR EL NOMBRE DE LA CARPETA DE SALIDA
            elif metodo_grafico == 7:
                descargar_csv_tipo(datos_sin_normalizar(),1) # 1 PARA SABER QUE VIENE SIN NORMALIZAR  
            elif metodo_grafico == 8:
                descargar_csv_acotado_tipo(datos_sin_normalizar(),1) # 1 PARA SABER QUE VIENE SIN NORMALIZAR  
            elif metodo_grafico == 9:
                main()
                
                
        elif opcion == '2':
            
            metodo = 2
            print("Como deseas ver el espectro")
            print("1-Grafico completo") #ok
            print("2-Grafico acotado") #ok
            print("3-Grafico por tipo") #ok
            print("4-Grafico acotado por tipo") #ok
            print("5- Descargar .csv normalizado por la media") #ok 
            print("6- Descargar .csv acotado por la media") #ok
            print("7- Descargar .csv por tipo") #ok
            print("8- Descargar .csv acotado por tipo")
            print("9-Volver") #ok
            metodo_grafico = int(input("Opcion: "))
            if metodo_grafico == 1:
                print("Procesando los datos")
                print("Por favor espere un momento...")
                mostrar_espectros(normalizado_media(),raman_shift,metodo)
            elif metodo_grafico == 2:
                espectro_acotado(normalizado_media(), 0,2)
            elif metodo_grafico == 3:
                grafico_tipo(normalizado_media(),raman_shift,metodo)
            elif metodo_grafico == 4:
                grafico_acotado_tipo(normalizado_media(),raman_shift,metodo)
            elif metodo_grafico == 5:
                descargar_csv(2) # 2 PARA SABER QUE VIENE DE LA MEDIA
            elif metodo_grafico == 6:
                descargar_csv_acotado(normalizado_media(),2) # 2 PARA SABER QUE VIENE DE ACA Y PODER ELEGIR EL NOMBRE DE LA CARPETA DE SALIDA
            elif metodo_grafico == 7:
                descargar_csv_tipo(normalizado_media(),2) # 2 PARA SABER QUE VIENE  NORMALIZAR MEDIA
            elif metodo_grafico == 8:
                descargar_csv_acotado_tipo(normalizado_media(),2) # 2 PARA SABER QUE VIENE SIN NORMALIZAR 
            elif metodo_grafico == 9:
                main()
                
                
        elif opcion == '3':
            
             metodo = 3
             print("Como deseas ver el espectro")
             print("1-Grafico completo")   #ok
             print("2-Grafico acotado") #ok
             print("3-Grafico por tipo") #ok
             print("4-Grafico acotado por tipo") #ok
             print("5-Descargar .csv normalizado por Area")  #ok
             print("6- Descargar .csv acotado por Area") #ok
             print("7- Descargar .csv por tipo") #ok
             print("8- Descargar .csv acotado por tipo")
             print("9-Volver") #ok
             metodo_grafico = int(input("Opcion: "))
                 
             if metodo_grafico == 1:
                 print("Procesando los datos")
                 print("Por favor espere un momento...")
                 mostrar_espectros(normalizado_area(),raman_shift,metodo)
             elif metodo_grafico == 2:
                 espectro_acotado(normalizado_area(), 0,3)
             elif metodo_grafico == 3:
                 grafico_tipo(normalizado_area(),raman_shift,metodo)
             elif metodo_grafico == 5:
                 descargar_csv(3) # 3 PARA SABER QUE VIENE DEL AREA
             elif metodo_grafico == 6:
                descargar_csv_acotado(normalizado_area(),3) # 3 PARA SABER QUE VIENE DE ACA Y PODER ELEGIR EL NOMBRE DE LA CARPETA DE SALIDA
             elif metodo_grafico == 7:
                 descargar_csv_tipo(normalizado_area(),3) # 3 PARA SABER QUE VIENE  NORMALIZAR AREA
             elif metodo_grafico == 8:
                 descargar_csv_acotado_tipo(normalizado_area(),3) # 3 PARA SABER QUE VIENE SIN NORMALIZAR 
             elif metodo_grafico == 9:
                 main()
         
        elif opcion == '4':        
             metodo = 4
             print("Como deseas ver el espectro")
             print("1-Grafico completo")
             print("2-Grafico acotado")
             print("3-Grafico por tipo")
             print("4-Grafico acotado por tipo")
             metodo_grafico = int(input("Opcion: "))
             if metodo_grafico == 1:
                 print("Procesando los datos")
                 print("Por favor espere un momento...")
                 suavizado_saviztky_golay(0,0)
             elif metodo_grafico == 2:
                 print("Procesando los datos")
                 print("Por favor espere un momento...")
                 espectro_acotado(suavizado_saviztky_golay(0,1), 2,4)
             elif metodo_grafico == 3:
                 print("NORMALIZAR POR:")
                 print("1-Media")
                 print("2-Area")
                 print("3-Sin normalizar")
                 opcion = int(input("Selecciona una opción: "))
                 if opcion == 1:
                     print("Procesando los datos")
                     print("Por favor espere un momento...")
                     grafico_tipo(suavizado_saviztky_golay(0,2),raman_shift,metodo,'1',0)
                 elif opcion == 2:
                     print("Procesando los datos")
                     print("Por favor espere un momento...")
                     grafico_tipo(suavizado_saviztky_golay(0,3),raman_shift,metodo,'2',0)
                 else: 
                     print("Procesando los datos")
                     print("Por favor espere un momento...")
                     grafico_tipo(suavizado_saviztky_golay(0,4),raman_shift,metodo,'3',0)
             # else
             #     #grafico_tipo_acotado()
             
             
             
        elif opcion == '15':
            print("Saliendo del programa...")
            break  
        else:
            print("Opción no válida. Inténtalo de nuevo.")


def descargar_csv(normalizado):
    if normalizado == 1:
        df.to_csv('output_sin_normalizar.csv', index=False, header=False)
        print("SE HA DESCARGADO EL ARCHIVO CON EL NOMBRE: output_sin_normalizar.csv")
    elif normalizado == 2:
        df_aux = normalizado_media() # obtenemos el dataframe              
        raman_shift_aux = raman_shift[:len(df_aux)] #nos aseguramos de que el tengan la misa longitud         
        df_aux.insert(0, '', raman_shift_aux)    # Insertamos la columna raman_shift en la posición 0
        df_aux.to_csv('output_media.csv', index=False, header=True)# Guardarmos el DataFrame en un archivo CSV
        print("SE HA DESCARGADO EL ARCHIVO CON EL NOMBRE: output_media.csv")
    elif normalizado == 3:
        df_aux = normalizado_area() # obtenemos el dataframe              
        raman_shift_aux = raman_shift[:len(df_aux)] #nos aseguramos de que el tengan la misa longitud         
        df_aux.insert(0, '', raman_shift_aux)    # Insertamos la columna raman_shift en la posición 0
        df_aux.to_csv('output_area.csv', index=False, header=True)# Guardarmos el DataFrame en un archivo CSV
        print("SE HA DESCARGADO EL ARCHIVO CON EL NOMBRE: output_area.csv")

def descargar_csv_acotado(datos, opcion):   # ESTA PARTE SE PUEDE OPTIMIZAR YA QUE 2-Grafico acotado  Y 6- Descargar .csv acotado por la media HACE LA MISMA COSA, SOLO QUE UNO GENERA UN .CSV Y EL OTRO LO GRAFICA
    df_aux = datos.to_numpy()
    #print("PRINT")
    #print(df_aux)
    cabecera_np = df.iloc[0, 1:].to_numpy()  # La primera fila contiene los encabezados
    #print("CABECERA_NP")
    #print(cabecera_np)
    intensidades_np = df_aux[:, :]  # Excluir la primera fila y primera columna
    #print("INTENSIDADES_NP")
    #print(intensidades_np)
    raman = df.iloc[1:, 0].to_numpy().astype(float)  # Primera columna (Raman Shift)
    #print("RAMAN")
    #print(raman)
    intensidades = intensidades_np.astype(float)  # Columnas restantes (intensidades)
    #print("INTENSIDADES")
    #print(intensidades)

    min_rango = int(input("Rango minimo: "))  
    max_rango = int(input("Rango maximo: "))  

    indices_acotados = (raman >= min_rango) & (raman <= max_rango)  
    #print("INDICES_ACOTADOS")
    #print(indices_acotados)
    #print(indices_acotados.shape)
    raman_acotado = raman[indices_acotados]
    #print("RAMAN_ACOTADO")
    #print(raman_acotado)
    intensidades_acotadas = intensidades[indices_acotados, :]
    #print("INTENSIDADES_ACOTADAS")
    #print(intensidades_acotadas)
    
    
    # Crear DataFrame filtrado
    df_acotado = pd.DataFrame(
        data=np.column_stack([raman_acotado, intensidades_acotadas]),
        columns=["Raman Shift"] + list(cabecera_np[:])  # Encabezados para el DataFrame
    )

    if opcion == 1:
        df_acotado.to_csv('output_acotado_sinNormalizar.csv', index=False, header=True)# Guardarmos el DataFrame en un archivo CSV
        print("SE HA DESCARGADO EL ARCHIVO CON EL NOMBRE: output_acotado_sinNormalizar.csv")
    elif opcion == 2:
        df_acotado.to_csv('output_acotado_media.csv', index=False, header=True)# Guardarmos el DataFrame en un archivo CSV
        print("SE HA DESCARGADO EL ARCHIVO CON EL NOMBRE: output_acotado_media.csv")
    elif opcion == 3:
        df_acotado.to_csv('output_acotado_area.csv', index=False, header=True)# Guardarmos el DataFrame en un archivo CSV
        print("SE HA DESCARGADO EL ARCHIVO CON EL NOMBRE: output_acotado_area.csv")
    

def descargar_csv_tipo(datos,opcion):
    
    mostrar_tipo = input("Ingrese el tipo que deseas visualizar: ")

    columnas_eliminar = [] # GUARDAMOS EN ESTA LISTA TODO LO QUE SE VAS A ELIMINAR

    for col in datos.columns:
       
        if col != mostrar_tipo: # SI ESA COLUMNA NO CONINCIDE CON EL TIPO DESEADO SE AGREGAR EN columnas_eliminar
            columnas_eliminar.append(col)
    

    datos_filtrados = datos.drop(columns=columnas_eliminar) # CREAMOS UN DATAFRAME ELIMINANDO TODO LO QUE ESTE DENTRO DE columnas_eliminar
    
    datos_filtrados.insert(0, "raman_shift",raman_shift)  # Insertamos en la primera posición los valores de raman_shift
    #print("Datos filtrados con 'raman_shift' agregado:")
    #print(datos_filtrados)
        
    
    
    if opcion == 1:
        datos_filtrados.to_csv('output_tipo_sinNormalizar.csv', index=False, header=True)# Guardarmos el DataFrame en un archivo CSV
        print("SE HA DESCARGADO EL ARCHIVO CON EL NOMBRE: output_tipo_sinNormalizar.csv")
    elif opcion == 2:
        datos_filtrados.to_csv('output_tipo_media.csv', index=False, header=True)# Guardarmos el DataFrame en un archivo CSV
        print("SE HA DESCARGADO EL ARCHIVO CON EL NOMBRE: output_tipo_media.csv")
    elif opcion == 3:
        datos_filtrados.to_csv('output_tipo_area.csv', index=False, header=True)# Guardarmos el DataFrame en un archivo CSV
        print("SE HA DESCARGADO EL ARCHIVO CON EL NOMBRE: output_tipo_area.csv")


def descargar_csv_acotado_tipo(datos,opcion):
   
    mostrar_tipo = input("Ingrese el tipo que deseas visualizar: ")


    columnas_eliminar = [] # GUARDAMOS EN ESTA LISTA TODO LO QUE SE VAS A ELIMINAR

    for col in datos.columns:
       
        if col != mostrar_tipo: # SI ESA COLUMNA NO CONINCIDE CON EL TIPO DESEADO SE AGREGAR EN columnas_eliminar
            columnas_eliminar.append(col)
    

    datos_filtrados = datos.drop(columns=columnas_eliminar) # CREAMOS UN DATAFRAME ELIMINANDO TODO LO QUE ESTE DENTRO DE columnas_eliminar
    
    datos_filtrados.insert(0, "raman_shift",raman_shift)  # Insertamos en la primera posición los valores de raman_shift
    #print("Datos filtrados con 'raman_shift' agregado:")
    #print(datos_filtrados)
    datos_filtrados = datos_filtrados.astype(object)  # Convierte todo el DataFrame a tipo object       
    df_aux = datos_filtrados.iloc[:,1:].to_numpy()
    #print("PRINT")
    #print(df_aux)
    datos_filtrados.iloc[0, 1:] = mostrar_tipo
    cabecera_np = datos_filtrados.iloc[0, 1:].to_numpy()  # La primera fila contiene los encabezados
    #print("CABECERA_NP")
    #print(cabecera_np)
    intensidades_np = df_aux[:, :]
    #print("INTENSIDADES_NP")
    #print(intensidades_np)
    raman = df.iloc[1:, 0].to_numpy().astype(float)  # Primera columna (Raman Shift)
    #print("RAMAN")
    #print(raman)
    intensidades = intensidades_np.astype(float)  # Columnas restantes (intensidades)
    # print("INTENSIDADES")
    # print(intensidades)
    
    min_rango = int(input("Rango minimo: "))  
    max_rango = int(input("Rango maximo: "))  
    
    indices_acotados = (raman >= min_rango) & (raman <= max_rango)  
    # print("INDICES_ACOTADOS")
    # print(indices_acotados)
    # print(indices_acotados.shape)
    raman_acotado = raman[indices_acotados]
    # print("RAMAN_ACOTADO")
    # print(raman_acotado)
    intensidades_acotadas = intensidades[indices_acotados, :]
    # print("INTENSIDADES_ACOTADAS")
    # print(intensidades_acotadas)
    
    # print("murio aca")
    
    # Crear DataFrame filtrado
    datos_acotado_tipo = pd.DataFrame(
        data=np.column_stack([raman_acotado, intensidades_acotadas]),
        columns=["Raman Shift"] + list(cabecera_np[:]) # Encabezados para el DataFrame
    )
    # print("datos_acotado_tipo ")
    # print(datos_acotado_tipo )
    
    if opcion == 1:
        datos_acotado_tipo.to_csv('output_acotado_tipo_sinNormalizar.csv', index=False, header=True)# Guardarmos el DataFrame en un archivo CSV
        print("SE HA DESCARGADO EL ARCHIVO CON EL NOMBRE: output_acotado_tipo_sinNormalizar.csv")
    elif opcion == 2:
        datos_acotado_tipo.to_csv('output_acotado_tipo_media.csv', index=False, header=True)# Guardarmos el DataFrame en un archivo CSV
        print("SE HA DESCARGADO EL ARCHIVO CON EL NOMBRE: output_acotado_tipo_media.csv")
    elif opcion == 3:
        datos_acotado_tipo.to_csv('output_acotado_tipo_area.csv', index=False, header=True)# Guardarmos el DataFrame en un archivo CSV
        print("SE HA DESCARGADO EL ARCHIVO CON EL NOMBRE: output_acotado_tipo_area.csv")



def mostrar_espectros(datos,raman_shift,metodo):
    
    
    #print("ENTRO EN MOSTRAR ESPECTROS")
    #print(datos)
    
    # Graficar los espectros
    plt.figure(figsize=(10, 6))
 
  
    leyendas_tipos = set()  # almacenamos los tipos que enocntramos y la funcion set() nos ayuda a quer no se repitan
    pos_y=0
    for col in datos.columns :
        #print('entro normal')
        #col agarrar el nombre de los tipos de cada columna
        for tipo in asignacion_colores:
            #print("wwwwwww")
            if tipo == col :
                color_actual= asignacion_colores[tipo] #ACA YA ENCONTRAMOS EL COLOR CORRESPONDIENTE A ESE TIPO   
                if isinstance(col, str):  #Verifica que el nombre de la columna sea un string
                    if tipo in leyendas_tipos:
                        plt.plot(raman_shift , datos[col], color=color_actual, alpha=0.5, linewidth = 0.1,label=col)   
                        break
                    else:
                        plt.plot(raman_shift , datos[col], color=color_actual, alpha=0.5, linewidth = 0.1) 
                        leyendas_tipos.add(tipo) 
                pos_y+=1 
    
    
    titulo_plot_mostrar(metodo)








def titulo_plot_mostrar(metodo):
    # TODO ESTE CONDICIONAL ES SOLO PARA QUE EL TITULO DEL GRAFICO MUESTRE POR CUAL METODO SE NORMALIZO
    if metodo == 1:
        plt.xlabel('Longitud de onda / Frecuencia')
        plt.ylabel('Intensidad')
        plt.title(f'Espectros del archivo {bd_name}')
        plt.show()
    elif metodo == 2:
        plt.xlabel('Longitud de onda / Frecuencia')
        plt.ylabel('Intensidad')
        plt.title(f'Espectros del archivo {bd_name} Normalizado por la Media')
        plt.show()
    elif metodo == 3:
        plt.xlabel('Longitud de onda / Frecuencia')
        plt.ylabel('Intensidad')
        plt.title(f'Espectros del archivo {bd_name} Normalizado por Area')
        plt.show()
        
  
def titulo_plot_acotado(nor_op,min_rango,max_rango):
     if nor_op == 1:
         plt.xlabel('Longitud de onda / Frecuencia')
         plt.ylabel('Intensidad')
         plt.title(f'Espectros del archivo {bd_name} en el rango de {min_rango} a {max_rango}')
         plt.show()
     elif nor_op == 2:
         plt.xlabel('Longitud de onda / Frecuencia')
         plt.ylabel('Intensidad')
         plt.title(f'Espectros del archivo {bd_name} normalizado por la media en el rango de {min_rango} a {max_rango}')
         plt.show()
     elif nor_op == 3:
         plt.xlabel('Longitud de onda / Frecuencia')
         plt.ylabel('Intensidad')
         plt.title(f'Espectros del archivo {bd_name} normalizado por la area en el rango de {min_rango} a {max_rango}')
         plt.show() 
     elif nor_op == 4:
         plt.xlabel('Longitud de onda / Frecuencia')
         plt.ylabel('Intensidad')
         plt.title(f'Espectros del archivo {bd_name}  SUAVIZADO POR SAVIZTKY-GOLAY en el rango de {min_rango} a {max_rango}')
         plt.show() 
     elif nor_op == 5:
         plt.xlabel('Longitud de onda / Frecuencia')
         plt.ylabel('Intensidad')
         plt.title(f'Espectros del archivo {bd_name}  SUAVIZADO POR FILTRO GAUSIANO en el rango de {min_rango} a {max_rango}')
         plt.show() 
     elif nor_op == 6:
         plt.xlabel('Longitud de onda / Frecuencia')
         plt.ylabel('Intensidad')
         plt.title(f'Espectros del archivo {bd_name}  SUAVIZADO POR MEDIA MOVIL en el rango de {min_rango} a {max_rango}')
         plt.show()
     elif nor_op == 8:
         plt.xlabel('Longitud de onda / Frecuencia')
         plt.ylabel('Intensidad')
         plt.title(f'Primera derivada del archivo {bd_name} en el rango de {min_rango} a {max_rango}')
         plt.show()
     elif nor_op == 9:
         plt.xlabel('Longitud de onda / Frecuencia')
         plt.ylabel('Intensidad')
         plt.title(f'Segunda derivada del archivo {bd_name} en el rango de {min_rango} a {max_rango}')
         plt.show()
        

def titulo_plot_tipo(metodo,mostrar_tipo,m_suavi):
    # TODO ESTE CONDICIONAL ES SOLO PARA QUE EL TITULO DEL GRAFICO MUESTRE POR CUAL METODO SE NORMALIZO
    if metodo == 1:
        plt.xlabel('Longitud de onda / Frecuencia')
        plt.ylabel('Intensidad')
        plt.title(f'Espectro del tipo: {mostrar_tipo} del archivo {bd_name} sin normalizar')
        plt.show()
    elif metodo == 2:
        plt.xlabel('Longitud de onda / Frecuencia')
        plt.ylabel('Intensidad')
        plt.title(f'Espectro del tipo: {mostrar_tipo} del archivo {bd_name} Normalizado por la Media')
        plt.show()
    elif metodo == 3:
        plt.xlabel('Longitud de onda / Frecuencia')
        plt.ylabel('Intensidad')
        plt.title(f'Espectro del tipo: {mostrar_tipo} del archivo {bd_name} Normalizado por Area')
        plt.show()
    elif metodo == 4:
        if opcion == '1':
            plt.xlabel('Longitud de onda / Frecuencia')
            plt.ylabel('Intensidad')
            plt.title(f'Espectro del tipo: {mostrar_tipo}  Suavizado por Saviztky_golay y Normalizado por la media')
            plt.show()   
        elif opcion == '2':
            plt.xlabel('Longitud de onda / Frecuencia')
            plt.ylabel('Intensidad')
            plt.title(f'Espectro del tipo: {mostrar_tipo} Suavizado por Saviztky_golay y Normalizado Area')
            plt.show() 
        else:
            plt.xlabel('Longitud de onda / Frecuencia')
            plt.ylabel('Intensidad')
            plt.title(f'Espectro del tipo: {mostrar_tipo}  Suavizado por Saviztky_golay y sin Normalizar ')
            plt.show()          
    elif metodo == 5:
        if opcion == '1':
            plt.xlabel('Longitud de onda / Frecuencia')
            plt.ylabel('Intensidad')
            plt.title(f'Espectro del tipo: {mostrar_tipo}  Suavizado por Filtro Gaussiano y Normalizado por la media')
            plt.show()   
        elif opcion == '2':
            plt.xlabel('Longitud de onda / Frecuencia')
            plt.ylabel('Intensidad')
            plt.title(f'Espectro del tipo: {mostrar_tipo}  Suavizado por Filtro Gaussiano y Normalizado Area')
            plt.show() 
        else:
            plt.xlabel('Longitud de onda / Frecuencia')
            plt.ylabel('Intensidad')
            plt.title(f'Espectro del tipo: {mostrar_tipo} Suavizado por Filtro Gaussiano y sin Normalizar ')
            plt.show() 
    elif metodo == 6:
        if opcion == '1':
            plt.xlabel('Longitud de onda / Frecuencia')
            plt.ylabel('Intensidad')
            plt.title(f'Espectro del tipo: {mostrar_tipo}  Suavizado por Media Movil y Normalizado por la media')
            plt.show()   
        elif opcion == '2':
            plt.xlabel('Longitud de onda / Frecuencia')
            plt.ylabel('Intensidad')
            plt.title(f'Espectro del tipo: {mostrar_tipo}  Suavizado por Media Movil y Normalizado Area')
            plt.show() 
        else:
            plt.xlabel('Longitud de onda / Frecuencia')
            plt.ylabel('Intensidad')
            plt.title(f'Espectro del tipo: {mostrar_tipo}  Suavizado por Media Movil y sin Normalizar ')
            plt.show() 
    elif metodo == 7:
            print("hola PCA")
    elif metodo == 8:
            plt.xlabel('Longitud de onda / Frecuencia')
            plt.ylabel('Intensidad')
            plt.title(f'Espectro del tipo: {mostrar_tipo}  por la primera derivada ')
            plt.show() 
    elif metodo == 9:
            plt.xlabel('Longitud de onda / Frecuencia')
            plt.ylabel('Intensidad')
            plt.title(f'Espectro del tipo: {mostrar_tipo}  por la primera derivada ')
            plt.show() 
    elif metodo == 10:
            if opcion == '1':
                if m_suavi == 1:
                    plt.xlabel('Longitud de onda / Frecuencia')
                    plt.ylabel('Intensidad')
                    plt.title(f'Espectros del archivo {bd_name} Suavizado por SAVIZTKY-GOLAY y Normalizado por la media')
                    plt.show()
                elif m_suavi == 2:
                    plt.xlabel('Longitud de onda / Frecuencia')
                    plt.ylabel('Intensidad')
                    plt.title(f'Espectros del archivo {bd_name} Suavizado por FILTRO GAUSIANO y Normalizado por la media')
                    plt.show()
                elif m_suavi == 3:
                    plt.xlabel('Longitud de onda / Frecuencia')
                    plt.ylabel('Intensidad')
                    plt.title(f'Espectros del archivo {bd_name} Suavizado por MEDIA MOVIL y Normalizado por la media')
                    plt.show()
                else:
                    plt.xlabel('Longitud de onda / Frecuencia')
                    plt.ylabel('Intensidad')
                    plt.title(f'Espectros del archivo {bd_name} sin suavizar y Normalizado por la media')
                    plt.show()
            elif opcion == '2':
                if m_suavi == 1:
                    plt.xlabel('Longitud de onda / Frecuencia')
                    plt.ylabel('Intensidad')
                    plt.title(f'Espectros del archivo {bd_name} Suavizado por SAVIZTKY-GOLAY y Normalizado por Area')
                    plt.show()
                elif m_suavi == 2:
                    plt.xlabel('Longitud de onda / Frecuencia')
                    plt.ylabel('Intensidad')
                    plt.title(f'Espectros del archivo {bd_name} Suavizado por FILTRO GAUSIANO y Normalizado por Area')
                    plt.show()
                elif m_suavi == 3:
                    plt.xlabel('Longitud de onda / Frecuencia')
                    plt.ylabel('Intensidad')
                    plt.title(f'Espectros del archivo {bd_name} Suavizado por MEDIA MOVIL y Normalizado por Area')
                    plt.show()
                else:
                    plt.xlabel('Longitud de onda / Frecuencia')
                    plt.ylabel('Intensidad')
                    plt.title(f'Espectros del archivo {bd_name} sin Suavizar y Normalizado por Area')
                    plt.show()
            else:
                if m_suavi == 1:
                    plt.xlabel('Longitud de onda / Frecuencia')
                    plt.ylabel('Intensidad')
                    plt.title(f'Espectros del archivo {bd_name} Suavizado por SAVIZTKY-GOLAY y Sin Normalizar')
                    plt.show()
                elif m_suavi == 2:
                    plt.xlabel('Longitud de onda / Frecuencia')
                    plt.ylabel('Intensidad')
                    plt.title(f'Espectros del archivo {bd_name} Suavizado por FILTRO GAUSIANO y Sin Normalizar')
                    plt.show()
                elif m_suavi == 3:
                    plt.xlabel('Longitud de onda / Frecuencia')
                    plt.ylabel('Intensidad')
                    plt.title(f'Espectros del archivo {bd_name} Suavizado por MEDIA MOVIL y Sin Normalizar')
                    plt.show()
                else:
                    plt.xlabel('Longitud de onda / Frecuencia')
                    plt.ylabel('Intensidad')
                    plt.title(f'Espectros del archivo {bd_name} sin Suavizar y Sin Normalizar')
                    plt.show()
    # elif metodo == 11:
    # elif metodo == 12:
    elif metodo == 13:
            plt.xlabel('Longitud de onda / Frecuencia')
            plt.ylabel('Intensidad')
            plt.title(f'Espectros del archivo {bd_name} Acotado ')
            plt.show() 
    else:
        print("NO HAY GRAFICA DISPONIBLE PARA ESTA OPCION")

 




def titulo_plot_tipo_acotado(metodo,mostrar_tipo,min_rango,max_rango,m_suavi):
    
 # TODO ESTE CONDICIONAL ES SOLO PARA QUE EL TITULO DEL GRAFICO MUESTRE POR CUAL METODO SE NORMALIZO
 if metodo == 1:
     plt.xlabel('Longitud de onda / Frecuencia')
     plt.ylabel('Intensidad')
     plt.title(f'Espectro del tipo: {mostrar_tipo} del archivo {bd_name} sin normalizar en el rango:[{min_rango},{max_rango}]')
     plt.show()
 elif metodo == 2:
     plt.xlabel('Longitud de onda / Frecuencia')
     plt.ylabel('Intensidad')
     plt.title(f'Espectro del tipo: {mostrar_tipo} del archivo {bd_name} Normalizado por la Media en el rango:[{min_rango},{max_rango}]')
     plt.show()
 elif metodo == 3:
     plt.xlabel('Longitud de onda / Frecuencia')
     plt.ylabel('Intensidad')
     plt.title(f'Espectro del tipo: {mostrar_tipo} del archivo {bd_name} Normalizado por Area en el rango:[{min_rango},{max_rango}]')
     plt.show()
 elif metodo == 4:
     if opcion == '1':
         plt.xlabel('Longitud de onda / Frecuencia')
         plt.ylabel('Intensidad')
         plt.title(f'Espectro del tipo: {mostrar_tipo}  Suavizado por Saviztky_golay y Normalizado por la media')
         plt.show()   
     elif opcion == '2':
         plt.xlabel('Longitud de onda / Frecuencia')
         plt.ylabel('Intensidad')
         plt.title(f'Espectro del tipo: {mostrar_tipo} Suavizado por Saviztky_golay y Normalizado Area')
         plt.show() 
     else:
         plt.xlabel('Longitud de onda / Frecuencia')
         plt.ylabel('Intensidad')
         plt.title(f'Espectro del tipo: {mostrar_tipo}  Suavizado por Saviztky_golay y sin Normalizar ')
         plt.show()          
 elif metodo == 5:
     if opcion == '1':
         plt.xlabel('Longitud de onda / Frecuencia')
         plt.ylabel('Intensidad')
         plt.title(f'Espectro del tipo: {mostrar_tipo}  Suavizado por Filtro Gaussiano y Normalizado por la media')
         plt.show()   
     elif opcion == '2':
         plt.xlabel('Longitud de onda / Frecuencia')
         plt.ylabel('Intensidad')
         plt.title(f'Espectro del tipo: {mostrar_tipo}  Suavizado por Filtro Gaussiano y Normalizado Area')
         plt.show() 
     else:
         plt.xlabel('Longitud de onda / Frecuencia')
         plt.ylabel('Intensidad')
         plt.title(f'Espectro del tipo: {mostrar_tipo} Suavizado por Filtro Gaussiano y sin Normalizar ')
         plt.show() 
 elif metodo == 6:
     if opcion == '1':
         plt.xlabel('Longitud de onda / Frecuencia')
         plt.ylabel('Intensidad')
         plt.title(f'Espectro del tipo: {mostrar_tipo}  Suavizado por Media Movil y Normalizado por la media')
         plt.show()   
     elif opcion == '2':
         plt.xlabel('Longitud de onda / Frecuencia')
         plt.ylabel('Intensidad')
         plt.title(f'Espectro del tipo: {mostrar_tipo}  Suavizado por Media Movil y Normalizado Area')
         plt.show() 
     else:
         plt.xlabel('Longitud de onda / Frecuencia')
         plt.ylabel('Intensidad')
         plt.title(f'Espectro del tipo: {mostrar_tipo}  Suavizado por Media Movil y sin Normalizar ')
         plt.show() 
 elif metodo == 7:
         print("hola PCA")
 elif metodo == 8:
         plt.xlabel('Longitud de onda / Frecuencia')
         plt.ylabel('Intensidad')
         plt.title(f'Espectro del tipo: {mostrar_tipo}  por la primera derivada ')
         plt.show() 
 elif metodo == 9:
         plt.xlabel('Longitud de onda / Frecuencia')
         plt.ylabel('Intensidad')
         plt.title(f'Espectro del tipo: {mostrar_tipo}  por la primera derivada ')
         plt.show() 
 elif metodo == 10:
         if opcion == '1':
             if m_suavi == 1:
                 plt.xlabel('Longitud de onda / Frecuencia')
                 plt.ylabel('Intensidad')
                 plt.title(f'Espectros del archivo {bd_name} Suavizado por SAVIZTKY-GOLAY y Normalizado por la media')
                 plt.show()
             elif m_suavi == 2:
                 plt.xlabel('Longitud de onda / Frecuencia')
                 plt.ylabel('Intensidad')
                 plt.title(f'Espectros del archivo {bd_name} Suavizado por FILTRO GAUSIANO y Normalizado por la media')
                 plt.show()
             elif m_suavi == 3:
                 plt.xlabel('Longitud de onda / Frecuencia')
                 plt.ylabel('Intensidad')
                 plt.title(f'Espectros del archivo {bd_name} Suavizado por MEDIA MOVIL y Normalizado por la media')
                 plt.show()
             else:
                 plt.xlabel('Longitud de onda / Frecuencia')
                 plt.ylabel('Intensidad')
                 plt.title(f'Espectros del archivo {bd_name} sin suavizar y Normalizado por la media')
                 plt.show()
         elif opcion == '2':
             if m_suavi == 1:
                 plt.xlabel('Longitud de onda / Frecuencia')
                 plt.ylabel('Intensidad')
                 plt.title(f'Espectros del archivo {bd_name} Suavizado por SAVIZTKY-GOLAY y Normalizado por Area')
                 plt.show()
             elif m_suavi == 2:
                 plt.xlabel('Longitud de onda / Frecuencia')
                 plt.ylabel('Intensidad')
                 plt.title(f'Espectros del archivo {bd_name} Suavizado por FILTRO GAUSIANO y Normalizado por Area')
                 plt.show()
             elif m_suavi == 3:
                 plt.xlabel('Longitud de onda / Frecuencia')
                 plt.ylabel('Intensidad')
                 plt.title(f'Espectros del archivo {bd_name} Suavizado por MEDIA MOVIL y Normalizado por Area')
                 plt.show()
             else:
                 plt.xlabel('Longitud de onda / Frecuencia')
                 plt.ylabel('Intensidad')
                 plt.title(f'Espectros del archivo {bd_name} sin Suavizar y Normalizado por Area')
                 plt.show()
         else:
             if m_suavi == 1:
                 plt.xlabel('Longitud de onda / Frecuencia')
                 plt.ylabel('Intensidad')
                 plt.title(f'Espectros del archivo {bd_name} Suavizado por SAVIZTKY-GOLAY y Sin Normalizar')
                 plt.show()
             elif m_suavi == 2:
                 plt.xlabel('Longitud de onda / Frecuencia')
                 plt.ylabel('Intensidad')
                 plt.title(f'Espectros del archivo {bd_name} Suavizado por FILTRO GAUSIANO y Sin Normalizar')
                 plt.show()
             elif m_suavi == 3:
                 plt.xlabel('Longitud de onda / Frecuencia')
                 plt.ylabel('Intensidad')
                 plt.title(f'Espectros del archivo {bd_name} Suavizado por MEDIA MOVIL y Sin Normalizar')
                 plt.show()
             else:
                 plt.xlabel('Longitud de onda / Frecuencia')
                 plt.ylabel('Intensidad')
                 plt.title(f'Espectros del archivo {bd_name} sin Suavizar y Sin Normalizar')
                 plt.show()
 # elif metodo == 11:
 # elif metodo == 12:
 elif metodo == 13:
         plt.xlabel('Longitud de onda / Frecuencia')
         plt.ylabel('Intensidad')
         plt.title(f'Espectros del archivo {bd_name} Acotado ')
         plt.show() 
 else:
     print("NO HAY GRAFICA DISPONIBLE PARA ESTA OPCION")




##### ver como solucionar el tema de los datos que tiran todo iguales sus graficos, 

def espectro_acotado(datos, pca_op,nor_op):
      
    df_aux = datos.to_numpy()
    print("PRINT")
    print(df_aux)
    cabecera_np = df.iloc[0, 1:].to_numpy()  # La primera fila contiene los encabezados
    print("CABECERA_NP")
    print(cabecera_np)
    intensidades_np = df_aux[:, :]  # Excluir la primera fila y primera columna
    print("INTENSIDADES_NP")
    print(intensidades_np)
    raman = df.iloc[1:, 0].to_numpy().astype(float)  # Primera columna (Raman Shift)
    print("RAMAN")
    print(raman)
    intensidades = intensidades_np.astype(float)  # Columnas restantes (intensidades)
    print("INTENSIDADES")
    print(intensidades)
    # Solicitar el rango
    min_rango = int(input("Rango minimo: "))  # Cambia según lo que necesites
    max_rango = int(input("Rango maximo: "))  # Cambia según lo que necesites
    
    # Filtrar los datos en el rango
    indices_acotados = (raman >= min_rango) & (raman <= max_rango)  # Filtra los índices
    print("INDICES_ACOTADOS")
    print(indices_acotados)
    print(indices_acotados.shape)
    raman_acotado = raman[indices_acotados]
    print("RAMAN_ACOTADO")
    print(raman_acotado)
    intensidades_acotadas = intensidades[indices_acotados, :]
    print("INTENSIDADES_ACOTADAS")
    print(intensidades_acotadas)
    
    
    # Crear DataFrame filtrado
    df_acotado = pd.DataFrame(
        data=np.column_stack([raman_acotado, intensidades_acotadas]),
        columns=["Raman Shift"] + list(cabecera_np[:])  # Encabezados para el DataFrame
    )

  
    if pca_op == 0 or pca_op == 2:
   
        # Graficar los espectros
        plt.figure(figsize=(10, 6))
    
        #print("entro en el graficador")
        #DESCOMENTAR EL CODIGO DE ABAJO ESE ES MIO, EL DE ARRIBA ES CHATGPT  
         
        leyendas = set()  # almacenamos los tipos que enocntramos y la funcion set() nos ayuda a quer no se repitan
        pos_y=0
        for col in df_acotado.columns :
                #print('entro normal')
              for tipo in asignacion_colores:
    
                    if tipo == col :
                      color_actual= asignacion_colores[tipo] #ACA YA ENCONTRAMOS EL COLOR CORRESPONDIENTE A ESE TIPO   
    
                      if isinstance(col, str):  #Verifica que el nombre de la columna sea un string
    
                            if tipo in leyendas:
                                
                                #print("error 1")
                                plt.plot(raman_acotado , df_acotado[col], color=color_actual, alpha=0.6, linewidth = 0.1,label=col) 
                                '''raman_shift:LE PASAMOS TODAS LAS INTENSIDADES , df2[col]= LE PASAMOS TODAS LAS COLUMNAS CON EL MISMO TIPO'''
      
                                break
                            else:
                                #print("error 2")
                                #print(raman)
                                #print(df_acotado[col])
                                plt.plot(raman_acotado , df_acotado[col], color=color_actual, alpha=0.6, linewidth = 0.1) 
                                leyendas.add(tipo) 
                      pos_y+=1 
           
    
        titulo_plot_acotado(nor_op,min_rango,max_rango)
        
    else: 
        return df_acotado , raman_acotado # creo que no hace falta retornarn nada ya que si una funcion le llama seria solamente para graficarla y retorna tiene quw retornar tambien su raman_shift acotado









def grafico_tipo(datos,raman_shift,metodo):

    
    #print("ENTRO EN MOSTRAR ESPECTROS")
    #print(datos)
    
    mostrar_tipo = input("Ingrese el tipo que deseas visualizar: ")
    
    print("Procesando los datos")
    print("Por favor espere un momento...")
    
    # Graficar los espectros
    plt.figure(figsize=(10, 6))
 
  
    leyendas_tipos = set()  # almacenamos los tipos que enocntramos y la funcion set() nos ayuda a quer no se repitan
    pos_y=0
    for col in datos.columns :
        if col == mostrar_tipo:
            #print("tipo seleccionado:", col)
            for tipo in asignacion_colores:
                #print("wwwwwww")
                if tipo == col :
                    color_actual= asignacion_colores[tipo] #ACA YA ENCONTRAMOS EL COLOR CORRESPONDIENTE A ESE TIPO   
                    if isinstance(col, str):  #Verifica que el nombre de la columna sea un string
                        if tipo in leyendas_tipos:
                            plt.plot(raman_shift , datos[col], color=color_actual, alpha=0.3, linewidth = 0.1,label=col)   
                            break
                        else:
                            plt.plot(raman_shift , datos[col], color=color_actual, alpha=0.3, linewidth = 0.1) 
                            leyendas_tipos.add(tipo) 
                    pos_y+=1 
    
    titulo_plot_tipo(metodo,mostrar_tipo,metodo)




def grafico_acotado_tipo(datos,raman_shift,metodo):
    
    mostrar_tipo = input("Ingrese el tipo que deseas visualizar: ")


    #print("ENTRO EN EL ESPECTRO ACOTADO")
    #print(datos)

    df_aux = datos.to_numpy()
        
    print("ENTRO EN EL ESPECTRO ACOTADO222")
    print(df_aux)
    print(df_aux.shape)
    
    cabecera_np = df.iloc[0,:].to_numpy()   # la primera fila contiene los encabezados
    cabecera_np = cabecera_np[1:]
    #print("la cabeceras son:")
    #print(cabecera_np)
    #print(cabecera_np.shape)
    
    
    intensidades_np = df_aux[: , :] # apartamos las intensidades
    #print("intensidades_np son:")
    #print(intensidades_np)
    #print(intensidades_np.shape)
    
    
    raman =  df.iloc[:, 0].to_numpy().astype(float)  # Primera columna (Raman Shift)
    raman = raman[1:]
    intensidades =  intensidades_np[:, 1:].astype(float)  # Columnas restantes (intensidades)
    # print("RAMAN:")
    # print(raman)
    # print(raman.shape)
    # print("INTENSIDADES:")
    # print(intensidades)
    # print(intensidades.shape)
    # Filtrado del rango de las intensidades
    min_rango = int(input("Rango minimo: "))  # Cambia según lo que necesites
    max_rango = int(input("Rango maximo: "))  # Cambia según lo que necesites
    
    
    print("Procesando los datos")
    print("Por favor espere un momento...")
    
    indices_acotados = (raman >= min_rango) & (raman <= max_rango) #retorna false o true para los que estan en el rango
    #print("Indices acotados")
    #print(indices_acotados)
    #print(indices_acotados.shape)
    
    raman_acotado = raman[indices_acotados]
    intensidades_acotadas = intensidades[indices_acotados,:]

    
        
    # # # Imprimir resultados
    # print("Raman Shift Acotado:")
    # print(raman_acotado)
    # print("\nIntensidades Acotadas:")
    # print(intensidades_acotadas)
        
    
    # Crear un DataFrame a partir de las dos variables
    df_acotado = pd.DataFrame(
    data=np.column_stack([raman_acotado, intensidades_acotadas]),
    columns=["Raman Shift"] + list(cabecera_np[1:])  # Encabezados para el DataFrame
    )

    # Mostrar el DataFrame resultante
    print("df_acotado")
    # df_acotado = pd.DataFrame(df_acotado)
    print(df_acotado)


   
    # Graficar los espectros
    plt.figure(figsize=(10, 6))
    
    #print("entro en el graficador")
    #DESCOMENTAR EL CODIGO DE ABAJO ESE ES MIO, EL DE ARRIBA ES CHATGPT  
         
    leyendas = set()  # almacenamos los tipos que enocntramos y la funcion set() nos ayuda a quer no se repitan
    pos_y=0
    for col in df_acotado.columns :
        if col == mostrar_tipo:
            for tipo in asignacion_colores:
                if tipo == col :
                    color_actual= asignacion_colores[tipo] #ACA YA ENCONTRAMOS EL COLOR CORRESPONDIENTE A ESE TIPO   
                    if isinstance(col, str):  #Verifica que el nombre de la columna sea un string
                        if tipo in leyendas:
                            #print("error 1")
                            plt.plot(raman_acotado , df_acotado[col], color=color_actual, alpha=0.6, linewidth = 0.1,label=col) 
                            '''raman_shift:LE PASAMOS TODAS LAS INTENSIDADES , df2[col]= LE PASAMOS TODAS LAS COLUMNAS CON EL MISMO TIPO'''
                            break
                        else:
                            #print("error 2")
                            #print(raman)
                            #print(df_acotado[col])
                            plt.plot(raman_acotado , df_acotado[col], color=color_actual, alpha=0.6, linewidth = 0.1) 
                            leyendas.add(tipo) 
                    pos_y+=1 
           
    
    titulo_plot_tipo_acotado(metodo,mostrar_tipo,min_rango,max_rango,0) #el 0 es por el m_suavi que no esta implementado aun
        



'''

# SUAVIZADO POR SAVIZTKY-GOLAY

def suavizado_saviztky_golay(normalizado_pca, pca_op):  #acordarse que se puede suavizar por la media, area y directo
    if pca_op == 0 or pca_op == 1:
        print("NORMALIZAR POR: xdf")
        print("1-MEDIA")
        print("2-AREA")
        print("3-SIN NORMALIZAR")
        opcion = input("Selecciona una opción: ")
        ventana = int(input("INGRESE EL VALOR DE LA VENTANA: "))
        orden = int(input("INGRESE EL VALOR DEL ORDEN: "))
        print("Procesando los datos")
        print("Por favor espere un momento...")
     
        if opcion == '1'  :
            normalizado_pca = df_media_pca
            #print(normalizado_pca)
        elif opcion == '2' :
            normalizado_pca = df_concatenado_cabecera_nueva_area
            #print(normalizado_pca)
        elif opcion == '3' :
            normalizado_pca = df2
            #print(normalizado_pca)
        else:
            print("OPCION NO VALIDA")
            print("SALIR...")
            #mostrar_menu()
    else:
        print("entro 3")
        ventana = int(input("INGRESE EL VALOR DE LA VENTANA: "))
        orden = int(input("INGRESE EL VALOR DEL ORDEN: "))
        print("Procesando los datos")
        print("Por favor espere un momento...")
        #ESTAS CONDICIONALES FUNCIONA PARA CUANDO ENTRE EN GRAFICAR POR TIPOS
        if pca_op == 2:
            normalizado_pca = df_media_pca
        elif pca_op == 3:
            normalizado_pca = df_concatenado_cabecera_nueva_area
        else:
            normalizado_pca = df2
     
      
    
    dato = normalizado_pca.to_numpy() #PASAMOS LOS DATOS A NUMPY POR QUE SAVGOL_FILTER USA SOLO NUMPY COMO PARAMETRO (PIERDE LA CABECERA DE TIPOS AL HACER ESTO)

    suavizado = savgol_filter(dato, window_length=ventana, polyorder=orden)
    suavizado_pd = pd.DataFrame(suavizado) # PASAMOS SUAVIZADO A PANDAS Y GUARDAMOS EN SUAVIZADO_PD
    suavizado_pd.columns = normalizado_pca.columns # AGREGAMOS LA CABECERA DE TIPOS
    
    #print(suavizado_pd)
    
    if pca_op == 0 or pca_op == 1:
        #print("Entro aca 2")
        #print(suavizado_pd) 
        if pca_op == 0:
            mostrar_espectros(suavizado_pd,raman_shift,4,opcion,0)
        else:
            return suavizado_pd
    else:
        #print("ESPECTRO SUAVIZADO POR SAVITZKY GOLAY")
        #print("suavizado savitkz golay:",suavizado_pd.shape) 
        #print(suavizado_pd)
        #print("aca si entro xD")
        return suavizado_pd
'''









#### CONTINUAR CON LOS METODOS DE SUAVIZADO, EMPEZAR CON SAVIZTKY-GOLAY















if __name__ == "__main__":
     main()


